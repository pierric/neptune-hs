{-
   Neptune Backend API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   Neptune Backend API API version: 2.8
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Neptune.Backend.Model
-}

{-# LANGUAGE DeriveDataTypeable         #-}
{-# LANGUAGE DeriveFoldable             #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DeriveTraversable          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase                 #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NamedFieldPuns             #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE RecordWildCards            #-}
{-# LANGUAGE TupleSections              #-}
{-# LANGUAGE TypeFamilies               #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Neptune.Backend.Model where

import           Neptune.Backend.Core
import           Neptune.Backend.MimeTypes

import           Data.Aeson                ((.:!), (.:), (.:?), (.=))

import qualified Control.Arrow             as P (left)
import qualified Data.Aeson                as A
import qualified Data.ByteString           as B
import qualified Data.ByteString.Base64    as B64
import qualified Data.ByteString.Char8     as BC
import qualified Data.ByteString.Lazy      as BL
import qualified Data.Data                 as P (TypeRep, Typeable, typeOf,
                                                 typeRep)
import qualified Data.Foldable             as P
import qualified Data.HashMap.Lazy         as HM
import qualified Data.Map                  as Map
import qualified Data.Maybe                as P
import qualified Data.Set                  as Set
import qualified Data.Text                 as T
import qualified Data.Text.Encoding        as T
import qualified Data.Time                 as TI
import qualified Lens.Micro                as L
import qualified Web.FormUrlEncoded        as WH
import qualified Web.HttpApiData           as WH

import           Control.Applicative       (Alternative, (<|>))
import           Data.Function             ((&))
import           Data.Monoid               ((<>))
import           Data.Text                 (Text)
import           Prelude                   (Applicative, Bool (..), Char,
                                            Double, FilePath, Float, Functor,
                                            Int, Integer, Maybe (..), Monad,
                                            String, fmap, maybe, mempty, pure,
                                            undefined, ($), (.), (/=), (<$>),
                                            (<*>), (=<<), (>>=))

import qualified Prelude                   as P



-- * Parameter newtypes


-- ** AvatarFile
newtype AvatarFile = AvatarFile { unAvatarFile :: FilePath } deriving (P.Eq, P.Show)

-- ** BackgroundFile
newtype BackgroundFile = BackgroundFile { unBackgroundFile :: FilePath } deriving (P.Eq, P.Show)

-- ** ChannelId
newtype ChannelId = ChannelId { unChannelId :: Text } deriving (P.Eq, P.Show)

-- ** ChannelsValues
newtype ChannelsValues = ChannelsValues { unChannelsValues :: [InputChannelValues] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** ChartId
newtype ChartId = ChartId { unChartId :: Text } deriving (P.Eq, P.Show)

-- ** ChartSetId
newtype ChartSetId = ChartSetId { unChartSetId :: Text } deriving (P.Eq, P.Show)

-- ** EndPoint
newtype EndPoint = EndPoint { unEndPoint :: Integer } deriving (P.Eq, P.Show)

-- ** ExperimentId
newtype ExperimentId = ExperimentId { unExperimentId :: Text } deriving (P.Eq, P.Show)

-- ** ExperimentIdentifier
newtype ExperimentIdentifier = ExperimentIdentifier { unExperimentIdentifier :: Text } deriving (P.Eq, P.Show)

-- ** ExperimentIdentity
newtype ExperimentIdentity = ExperimentIdentity { unExperimentIdentity :: Text } deriving (P.Eq, P.Show)

-- ** ExperimentIds
newtype ExperimentIds = ExperimentIds { unExperimentIds :: [Text] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Gzipped
newtype Gzipped = Gzipped { unGzipped :: Bool } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)

-- ** Ids
newtype Ids = Ids { unIds :: [Text] } deriving (P.Eq, P.Show)

-- ** IncludeInvitations
newtype IncludeInvitations = IncludeInvitations { unIncludeInvitations :: Bool } deriving (P.Eq, P.Show)

-- ** InvitationId
newtype InvitationId = InvitationId { unInvitationId :: Text } deriving (P.Eq, P.Show)

-- ** ItemCount
newtype ItemCount = ItemCount { unItemCount :: Int } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** MarkOnly
newtype MarkOnly = MarkOnly { unMarkOnly :: Bool } deriving (P.Eq, P.Show)

-- ** MetricId
newtype MetricId = MetricId { unMetricId :: Text } deriving (P.Eq, P.Show)

-- ** MetricValues
newtype MetricValues = MetricValues { unMetricValues :: [SystemMetricValues] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** OrgRelation
newtype OrgRelation = OrgRelation { unOrgRelation :: [Text] } deriving (P.Eq, P.Show)

-- ** Organization
newtype Organization = Organization { unOrganization :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationId
newtype OrganizationId = OrganizationId { unOrganizationId :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationIdentifier
newtype OrganizationIdentifier = OrganizationIdentifier { unOrganizationIdentifier :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationName
newtype OrganizationName = OrganizationName { unOrganizationName :: Text } deriving (P.Eq, P.Show)

-- ** Path
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)

-- ** ProjectId
newtype ProjectId = ProjectId { unProjectId :: Text } deriving (P.Eq, P.Show)

-- ** ProjectIdentifier
newtype ProjectIdentifier = ProjectIdentifier { unProjectIdentifier :: Text } deriving (P.Eq, P.Show)

-- ** ProjectIdentifierText
newtype ProjectIdentifierText = ProjectIdentifierText { unProjectIdentifierText :: [Text] } deriving (P.Eq, P.Show)

-- ** ProjectKey
newtype ProjectKey = ProjectKey { unProjectKey :: Text } deriving (P.Eq, P.Show)

-- ** ProjectName
newtype ProjectName = ProjectName { unProjectName :: Text } deriving (P.Eq, P.Show)

-- ** Resource
newtype Resource = Resource { unResource :: Text } deriving (P.Eq, P.Show)

-- ** SearchTerm
newtype SearchTerm = SearchTerm { unSearchTerm :: Text } deriving (P.Eq, P.Show)

-- ** SortBy
newtype SortBy = SortBy { unSortBy :: [Text] } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: [Text] } deriving (P.Eq, P.Show)

-- ** StartPoint
newtype StartPoint = StartPoint { unStartPoint :: Integer } deriving (P.Eq, P.Show)

-- ** UserId
newtype UserId = UserId { unUserId :: Text } deriving (P.Eq, P.Show)

-- ** UserRelation
newtype UserRelation = UserRelation { unUserRelation :: Text } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: [Text] } deriving (P.Eq, P.Show)

-- ** UsernamePrefix
newtype UsernamePrefix = UsernamePrefix { unUsernamePrefix :: Text } deriving (P.Eq, P.Show)

-- ** UsernameText
newtype UsernameText = UsernameText { unUsernameText :: Text } deriving (P.Eq, P.Show)

-- ** ViewedUsername
newtype ViewedUsername = ViewedUsername { unViewedUsername :: Text } deriving (P.Eq, P.Show)

-- ** Visibility
newtype Visibility = Visibility { unVisibility :: Text } deriving (P.Eq, P.Show)

-- ** WorkspaceName
newtype WorkspaceName = WorkspaceName { unWorkspaceName :: Text } deriving (P.Eq, P.Show)

-- ** XNeptuneApiToken
newtype XNeptuneApiToken = XNeptuneApiToken { unXNeptuneApiToken :: Text } deriving (P.Eq, P.Show)

-- ** XNeptuneCliVersion
newtype XNeptuneCliVersion = XNeptuneCliVersion { unXNeptuneCliVersion :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AchievementsDTO
-- | AchievementsDTO
data AchievementsDTO = AchievementsDTO
    { achievementsDTOEarned :: !([AchievementTypeDTO]) -- ^ /Required/ "earned"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AchievementsDTO
instance A.FromJSON AchievementsDTO where
  parseJSON = A.withObject "AchievementsDTO" $ \o ->
    AchievementsDTO
      <$> (o .:  "earned")

-- | ToJSON AchievementsDTO
instance A.ToJSON AchievementsDTO where
  toJSON AchievementsDTO {..} =
   _omitNulls
      [ "earned" .= achievementsDTOEarned
      ]


-- | Construct a value of type 'AchievementsDTO' (by applying it's required fields, if any)
mkAchievementsDTO
  :: [AchievementTypeDTO] -- ^ 'achievementsDTOEarned'
  -> AchievementsDTO
mkAchievementsDTO achievementsDTOEarned =
  AchievementsDTO
  { achievementsDTOEarned
  }

-- ** AuthorizedUserDTO
-- | AuthorizedUserDTO
data AuthorizedUserDTO = AuthorizedUserDTO
    { authorizedUserDTOUsername :: !(Text) -- ^ /Required/ "username"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthorizedUserDTO
instance A.FromJSON AuthorizedUserDTO where
  parseJSON = A.withObject "AuthorizedUserDTO" $ \o ->
    AuthorizedUserDTO
      <$> (o .:  "username")

-- | ToJSON AuthorizedUserDTO
instance A.ToJSON AuthorizedUserDTO where
  toJSON AuthorizedUserDTO {..} =
   _omitNulls
      [ "username" .= authorizedUserDTOUsername
      ]


-- | Construct a value of type 'AuthorizedUserDTO' (by applying it's required fields, if any)
mkAuthorizedUserDTO
  :: Text -- ^ 'authorizedUserDTOUsername'
  -> AuthorizedUserDTO
mkAuthorizedUserDTO authorizedUserDTOUsername =
  AuthorizedUserDTO
  { authorizedUserDTOUsername
  }

-- ** BatchChannelValueErrorDTO
-- | BatchChannelValueErrorDTO
data BatchChannelValueErrorDTO = BatchChannelValueErrorDTO
    { batchChannelValueErrorDTOChannelId :: !(Text) -- ^ /Required/ "channelId"
    -- ^ /Required/ "x"
    , batchChannelValueErrorDTOX         :: !(Double) -- ^ /Required/ "x"
    -- ^ /Required/ "error"
    , batchChannelValueErrorDTOError     :: !(Error) -- ^ /Required/ "error"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchChannelValueErrorDTO
instance A.FromJSON BatchChannelValueErrorDTO where
  parseJSON = A.withObject "BatchChannelValueErrorDTO" $ \o ->
    BatchChannelValueErrorDTO
      <$> (o .:  "channelId")
      <*> (o .:  "x")
      <*> (o .:  "error")

-- | ToJSON BatchChannelValueErrorDTO
instance A.ToJSON BatchChannelValueErrorDTO where
  toJSON BatchChannelValueErrorDTO {..} =
   _omitNulls
      [ "channelId" .= batchChannelValueErrorDTOChannelId
      , "x" .= batchChannelValueErrorDTOX
      , "error" .= batchChannelValueErrorDTOError
      ]


-- | Construct a value of type 'BatchChannelValueErrorDTO' (by applying it's required fields, if any)
mkBatchChannelValueErrorDTO
  :: Text -- ^ 'batchChannelValueErrorDTOChannelId'
  -> Double -- ^ 'batchChannelValueErrorDTOX'
  -> Error -- ^ 'batchChannelValueErrorDTOError'
  -> BatchChannelValueErrorDTO
mkBatchChannelValueErrorDTO batchChannelValueErrorDTOChannelId batchChannelValueErrorDTOX batchChannelValueErrorDTOError =
  BatchChannelValueErrorDTO
  { batchChannelValueErrorDTOChannelId
  , batchChannelValueErrorDTOX
  , batchChannelValueErrorDTOError
  }

-- ** BatchExperimentUpdateResult
-- | BatchExperimentUpdateResult
data BatchExperimentUpdateResult = BatchExperimentUpdateResult
    { batchExperimentUpdateResultExperimentId :: !(Text) -- ^ /Required/ "experimentId"
    -- ^ "error"
    , batchExperimentUpdateResultError        :: !(Maybe Error) -- ^ "error"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchExperimentUpdateResult
instance A.FromJSON BatchExperimentUpdateResult where
  parseJSON = A.withObject "BatchExperimentUpdateResult" $ \o ->
    BatchExperimentUpdateResult
      <$> (o .:  "experimentId")
      <*> (o .:? "error")

-- | ToJSON BatchExperimentUpdateResult
instance A.ToJSON BatchExperimentUpdateResult where
  toJSON BatchExperimentUpdateResult {..} =
   _omitNulls
      [ "experimentId" .= batchExperimentUpdateResultExperimentId
      , "error" .= batchExperimentUpdateResultError
      ]


-- | Construct a value of type 'BatchExperimentUpdateResult' (by applying it's required fields, if any)
mkBatchExperimentUpdateResult
  :: Text -- ^ 'batchExperimentUpdateResultExperimentId'
  -> BatchExperimentUpdateResult
mkBatchExperimentUpdateResult batchExperimentUpdateResultExperimentId =
  BatchExperimentUpdateResult
  { batchExperimentUpdateResultExperimentId
  , batchExperimentUpdateResultError = Nothing
  }

-- ** Channel
-- | Channel
data Channel = Channel
    { channelId          :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "name"
    , channelName        :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "channelType"
    , channelChannelType :: !(ChannelType) -- ^ /Required/ "channelType"
    -- ^ "lastX"
    , channelLastX       :: !(Maybe Double) -- ^ "lastX"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Channel
instance A.FromJSON Channel where
  parseJSON = A.withObject "Channel" $ \o ->
    Channel
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "channelType")
      <*> (o .:? "lastX")

-- | ToJSON Channel
instance A.ToJSON Channel where
  toJSON Channel {..} =
   _omitNulls
      [ "id" .= channelId
      , "name" .= channelName
      , "channelType" .= channelChannelType
      , "lastX" .= channelLastX
      ]


-- | Construct a value of type 'Channel' (by applying it's required fields, if any)
mkChannel
  :: Text -- ^ 'channelId'
  -> Text -- ^ 'channelName'
  -> ChannelType -- ^ 'channelChannelType'
  -> Channel
mkChannel channelId channelName channelChannelType =
  Channel
  { channelId
  , channelName
  , channelChannelType
  , channelLastX = Nothing
  }

-- ** ChannelDTO
-- | ChannelDTO
data ChannelDTO = ChannelDTO
    { channelDTOId          :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "name"
    , channelDTOName        :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "channelType"
    , channelDTOChannelType :: !(ChannelTypeEnum) -- ^ /Required/ "channelType"
    -- ^ "lastX"
    , channelDTOLastX       :: !(Maybe Double) -- ^ "lastX"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChannelDTO
instance A.FromJSON ChannelDTO where
  parseJSON = A.withObject "ChannelDTO" $ \o ->
    ChannelDTO
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "channelType")
      <*> (o .:? "lastX")

-- | ToJSON ChannelDTO
instance A.ToJSON ChannelDTO where
  toJSON ChannelDTO {..} =
   _omitNulls
      [ "id" .= channelDTOId
      , "name" .= channelDTOName
      , "channelType" .= channelDTOChannelType
      , "lastX" .= channelDTOLastX
      ]


-- | Construct a value of type 'ChannelDTO' (by applying it's required fields, if any)
mkChannelDTO
  :: Text -- ^ 'channelDTOId'
  -> Text -- ^ 'channelDTOName'
  -> ChannelTypeEnum -- ^ 'channelDTOChannelType'
  -> ChannelDTO
mkChannelDTO channelDTOId channelDTOName channelDTOChannelType =
  ChannelDTO
  { channelDTOId
  , channelDTOName
  , channelDTOChannelType
  , channelDTOLastX = Nothing
  }

-- ** ChannelParams
-- | ChannelParams
data ChannelParams = ChannelParams
    { channelParamsName        :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "channelType"
    , channelParamsChannelType :: !(ChannelTypeEnum) -- ^ /Required/ "channelType"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChannelParams
instance A.FromJSON ChannelParams where
  parseJSON = A.withObject "ChannelParams" $ \o ->
    ChannelParams
      <$> (o .:  "name")
      <*> (o .:  "channelType")

-- | ToJSON ChannelParams
instance A.ToJSON ChannelParams where
  toJSON ChannelParams {..} =
   _omitNulls
      [ "name" .= channelParamsName
      , "channelType" .= channelParamsChannelType
      ]


-- | Construct a value of type 'ChannelParams' (by applying it's required fields, if any)
mkChannelParams
  :: Text -- ^ 'channelParamsName'
  -> ChannelTypeEnum -- ^ 'channelParamsChannelType'
  -> ChannelParams
mkChannelParams channelParamsName channelParamsChannelType =
  ChannelParams
  { channelParamsName
  , channelParamsChannelType
  }

-- ** ChannelWithValue
-- | ChannelWithValue
data ChannelWithValue = ChannelWithValue
    { channelWithValueX           :: !(Double) -- ^ /Required/ "x"
    -- ^ /Required/ "y"
    , channelWithValueY           :: !(Text) -- ^ /Required/ "y"
    -- ^ /Required/ "channelType"
    , channelWithValueChannelType :: !(ChannelType) -- ^ /Required/ "channelType"
    -- ^ /Required/ "channelName"
    , channelWithValueChannelName :: !(Text) -- ^ /Required/ "channelName"
    -- ^ /Required/ "channelId"
    , channelWithValueChannelId   :: !(Text) -- ^ /Required/ "channelId"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChannelWithValue
instance A.FromJSON ChannelWithValue where
  parseJSON = A.withObject "ChannelWithValue" $ \o ->
    ChannelWithValue
      <$> (o .:  "x")
      <*> (o .:  "y")
      <*> (o .:  "channelType")
      <*> (o .:  "channelName")
      <*> (o .:  "channelId")

-- | ToJSON ChannelWithValue
instance A.ToJSON ChannelWithValue where
  toJSON ChannelWithValue {..} =
   _omitNulls
      [ "x" .= channelWithValueX
      , "y" .= channelWithValueY
      , "channelType" .= channelWithValueChannelType
      , "channelName" .= channelWithValueChannelName
      , "channelId" .= channelWithValueChannelId
      ]


-- | Construct a value of type 'ChannelWithValue' (by applying it's required fields, if any)
mkChannelWithValue
  :: Double -- ^ 'channelWithValueX'
  -> Text -- ^ 'channelWithValueY'
  -> ChannelType -- ^ 'channelWithValueChannelType'
  -> Text -- ^ 'channelWithValueChannelName'
  -> Text -- ^ 'channelWithValueChannelId'
  -> ChannelWithValue
mkChannelWithValue channelWithValueX channelWithValueY channelWithValueChannelType channelWithValueChannelName channelWithValueChannelId =
  ChannelWithValue
  { channelWithValueX
  , channelWithValueY
  , channelWithValueChannelType
  , channelWithValueChannelName
  , channelWithValueChannelId
  }

-- ** ChannelWithValueDTO
-- | ChannelWithValueDTO
data ChannelWithValueDTO = ChannelWithValueDTO
    { channelWithValueDTOX           :: !(Double) -- ^ /Required/ "x"
    -- ^ /Required/ "y"
    , channelWithValueDTOY           :: !(Text) -- ^ /Required/ "y"
    -- ^ /Required/ "channelType"
    , channelWithValueDTOChannelType :: !(ChannelTypeEnum) -- ^ /Required/ "channelType"
    -- ^ /Required/ "channelName"
    , channelWithValueDTOChannelName :: !(Text) -- ^ /Required/ "channelName"
    -- ^ /Required/ "channelId"
    , channelWithValueDTOChannelId   :: !(Text) -- ^ /Required/ "channelId"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChannelWithValueDTO
instance A.FromJSON ChannelWithValueDTO where
  parseJSON = A.withObject "ChannelWithValueDTO" $ \o ->
    ChannelWithValueDTO
      <$> (o .:  "x")
      <*> (o .:  "y")
      <*> (o .:  "channelType")
      <*> (o .:  "channelName")
      <*> (o .:  "channelId")

-- | ToJSON ChannelWithValueDTO
instance A.ToJSON ChannelWithValueDTO where
  toJSON ChannelWithValueDTO {..} =
   _omitNulls
      [ "x" .= channelWithValueDTOX
      , "y" .= channelWithValueDTOY
      , "channelType" .= channelWithValueDTOChannelType
      , "channelName" .= channelWithValueDTOChannelName
      , "channelId" .= channelWithValueDTOChannelId
      ]


-- | Construct a value of type 'ChannelWithValueDTO' (by applying it's required fields, if any)
mkChannelWithValueDTO
  :: Double -- ^ 'channelWithValueDTOX'
  -> Text -- ^ 'channelWithValueDTOY'
  -> ChannelTypeEnum -- ^ 'channelWithValueDTOChannelType'
  -> Text -- ^ 'channelWithValueDTOChannelName'
  -> Text -- ^ 'channelWithValueDTOChannelId'
  -> ChannelWithValueDTO
mkChannelWithValueDTO channelWithValueDTOX channelWithValueDTOY channelWithValueDTOChannelType channelWithValueDTOChannelName channelWithValueDTOChannelId =
  ChannelWithValueDTO
  { channelWithValueDTOX
  , channelWithValueDTOY
  , channelWithValueDTOChannelType
  , channelWithValueDTOChannelName
  , channelWithValueDTOChannelId
  }

-- ** Chart
-- | Chart
data Chart = Chart
    { chartId     :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "name"
    , chartName   :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "series"
    , chartSeries :: !([Series]) -- ^ /Required/ "series"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Chart
instance A.FromJSON Chart where
  parseJSON = A.withObject "Chart" $ \o ->
    Chart
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "series")

-- | ToJSON Chart
instance A.ToJSON Chart where
  toJSON Chart {..} =
   _omitNulls
      [ "id" .= chartId
      , "name" .= chartName
      , "series" .= chartSeries
      ]


-- | Construct a value of type 'Chart' (by applying it's required fields, if any)
mkChart
  :: Text -- ^ 'chartId'
  -> Text -- ^ 'chartName'
  -> [Series] -- ^ 'chartSeries'
  -> Chart
mkChart chartId chartName chartSeries =
  Chart
  { chartId
  , chartName
  , chartSeries
  }

-- ** ChartDefinition
-- | ChartDefinition
data ChartDefinition = ChartDefinition
    { chartDefinitionName   :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "series"
    , chartDefinitionSeries :: !([SeriesDefinition]) -- ^ /Required/ "series"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChartDefinition
instance A.FromJSON ChartDefinition where
  parseJSON = A.withObject "ChartDefinition" $ \o ->
    ChartDefinition
      <$> (o .:  "name")
      <*> (o .:  "series")

-- | ToJSON ChartDefinition
instance A.ToJSON ChartDefinition where
  toJSON ChartDefinition {..} =
   _omitNulls
      [ "name" .= chartDefinitionName
      , "series" .= chartDefinitionSeries
      ]


-- | Construct a value of type 'ChartDefinition' (by applying it's required fields, if any)
mkChartDefinition
  :: Text -- ^ 'chartDefinitionName'
  -> [SeriesDefinition] -- ^ 'chartDefinitionSeries'
  -> ChartDefinition
mkChartDefinition chartDefinitionName chartDefinitionSeries =
  ChartDefinition
  { chartDefinitionName
  , chartDefinitionSeries
  }

-- ** ChartSet
-- | ChartSet
data ChartSet = ChartSet
    { chartSetIsEditable           :: !(Maybe Bool) -- ^ "isEditable"
    -- ^ "defaultChartsEnabled"
    , chartSetDefaultChartsEnabled :: !(Maybe Bool) -- ^ "defaultChartsEnabled"
    -- ^ /Required/ "projectId"
    , chartSetProjectId            :: !(Text) -- ^ /Required/ "projectId"
    -- ^ /Required/ "id"
    , chartSetId                   :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "name"
    , chartSetName                 :: !(Text) -- ^ /Required/ "name"
    -- ^ "charts"
    , chartSetCharts               :: !(Maybe [Chart]) -- ^ "charts"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChartSet
instance A.FromJSON ChartSet where
  parseJSON = A.withObject "ChartSet" $ \o ->
    ChartSet
      <$> (o .:? "isEditable")
      <*> (o .:? "defaultChartsEnabled")
      <*> (o .:  "projectId")
      <*> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "charts")

-- | ToJSON ChartSet
instance A.ToJSON ChartSet where
  toJSON ChartSet {..} =
   _omitNulls
      [ "isEditable" .= chartSetIsEditable
      , "defaultChartsEnabled" .= chartSetDefaultChartsEnabled
      , "projectId" .= chartSetProjectId
      , "id" .= chartSetId
      , "name" .= chartSetName
      , "charts" .= chartSetCharts
      ]


-- | Construct a value of type 'ChartSet' (by applying it's required fields, if any)
mkChartSet
  :: Text -- ^ 'chartSetProjectId'
  -> Text -- ^ 'chartSetId'
  -> Text -- ^ 'chartSetName'
  -> ChartSet
mkChartSet chartSetProjectId chartSetId chartSetName =
  ChartSet
  { chartSetIsEditable = Nothing
  , chartSetDefaultChartsEnabled = Nothing
  , chartSetProjectId
  , chartSetId
  , chartSetName
  , chartSetCharts = Nothing
  }

-- ** ChartSetParams
-- | ChartSetParams
data ChartSetParams = ChartSetParams
    { chartSetParamsName                 :: !(Text) -- ^ /Required/ "name"
    -- ^ "charts"
    , chartSetParamsCharts               :: !(Maybe [ChartDefinition]) -- ^ "charts"
    -- ^ "defaultChartsEnabled"
    , chartSetParamsDefaultChartsEnabled :: !(Maybe Bool) -- ^ "defaultChartsEnabled"
    -- ^ "isEditable"
    , chartSetParamsIsEditable           :: !(Maybe Bool) -- ^ "isEditable"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChartSetParams
instance A.FromJSON ChartSetParams where
  parseJSON = A.withObject "ChartSetParams" $ \o ->
    ChartSetParams
      <$> (o .:  "name")
      <*> (o .:? "charts")
      <*> (o .:? "defaultChartsEnabled")
      <*> (o .:? "isEditable")

-- | ToJSON ChartSetParams
instance A.ToJSON ChartSetParams where
  toJSON ChartSetParams {..} =
   _omitNulls
      [ "name" .= chartSetParamsName
      , "charts" .= chartSetParamsCharts
      , "defaultChartsEnabled" .= chartSetParamsDefaultChartsEnabled
      , "isEditable" .= chartSetParamsIsEditable
      ]


-- | Construct a value of type 'ChartSetParams' (by applying it's required fields, if any)
mkChartSetParams
  :: Text -- ^ 'chartSetParamsName'
  -> ChartSetParams
mkChartSetParams chartSetParamsName =
  ChartSetParams
  { chartSetParamsName
  , chartSetParamsCharts = Nothing
  , chartSetParamsDefaultChartsEnabled = Nothing
  , chartSetParamsIsEditable = Nothing
  }

-- ** Charts
-- | Charts
data Charts = Charts
    { chartsManualCharts  :: !([Chart]) -- ^ /Required/ "manualCharts"
    -- ^ /Required/ "defaultCharts"
    , chartsDefaultCharts :: !([Chart]) -- ^ /Required/ "defaultCharts"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Charts
instance A.FromJSON Charts where
  parseJSON = A.withObject "Charts" $ \o ->
    Charts
      <$> (o .:  "manualCharts")
      <*> (o .:  "defaultCharts")

-- | ToJSON Charts
instance A.ToJSON Charts where
  toJSON Charts {..} =
   _omitNulls
      [ "manualCharts" .= chartsManualCharts
      , "defaultCharts" .= chartsDefaultCharts
      ]


-- | Construct a value of type 'Charts' (by applying it's required fields, if any)
mkCharts
  :: [Chart] -- ^ 'chartsManualCharts'
  -> [Chart] -- ^ 'chartsDefaultCharts'
  -> Charts
mkCharts chartsManualCharts chartsDefaultCharts =
  Charts
  { chartsManualCharts
  , chartsDefaultCharts
  }

-- ** ClientConfig
-- | ClientConfig
data ClientConfig = ClientConfig
    { clientConfigApiUrl         :: !(Text) -- ^ /Required/ "apiUrl"
    -- ^ /Required/ "applicationUrl"
    , clientConfigApplicationUrl :: !(Text) -- ^ /Required/ "applicationUrl"
    -- ^ /Required/ "pyLibVersions"
    , clientConfigPyLibVersions  :: !(ClientVersionsConfigDTO) -- ^ /Required/ "pyLibVersions"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClientConfig
instance A.FromJSON ClientConfig where
  parseJSON = A.withObject "ClientConfig" $ \o ->
    ClientConfig
      <$> (o .:  "apiUrl")
      <*> (o .:  "applicationUrl")
      <*> (o .:  "pyLibVersions")

-- | ToJSON ClientConfig
instance A.ToJSON ClientConfig where
  toJSON ClientConfig {..} =
   _omitNulls
      [ "apiUrl" .= clientConfigApiUrl
      , "applicationUrl" .= clientConfigApplicationUrl
      , "pyLibVersions" .= clientConfigPyLibVersions
      ]


-- | Construct a value of type 'ClientConfig' (by applying it's required fields, if any)
mkClientConfig
  :: Text -- ^ 'clientConfigApiUrl'
  -> Text -- ^ 'clientConfigApplicationUrl'
  -> ClientVersionsConfigDTO -- ^ 'clientConfigPyLibVersions'
  -> ClientConfig
mkClientConfig clientConfigApiUrl clientConfigApplicationUrl clientConfigPyLibVersions =
  ClientConfig
  { clientConfigApiUrl
  , clientConfigApplicationUrl
  , clientConfigPyLibVersions
  }

-- ** ClientVersionsConfigDTO
-- | ClientVersionsConfigDTO
data ClientVersionsConfigDTO = ClientVersionsConfigDTO
    { clientVersionsConfigDTOMinRecommendedVersion :: !(Maybe Text) -- ^ "minRecommendedVersion"
    -- ^ "minCompatibleVersion"
    , clientVersionsConfigDTOMinCompatibleVersion  :: !(Maybe Text) -- ^ "minCompatibleVersion"
    -- ^ "maxCompatibleVersion"
    , clientVersionsConfigDTOMaxCompatibleVersion  :: !(Maybe Text) -- ^ "maxCompatibleVersion"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClientVersionsConfigDTO
instance A.FromJSON ClientVersionsConfigDTO where
  parseJSON = A.withObject "ClientVersionsConfigDTO" $ \o ->
    ClientVersionsConfigDTO
      <$> (o .:? "minRecommendedVersion")
      <*> (o .:? "minCompatibleVersion")
      <*> (o .:? "maxCompatibleVersion")

-- | ToJSON ClientVersionsConfigDTO
instance A.ToJSON ClientVersionsConfigDTO where
  toJSON ClientVersionsConfigDTO {..} =
   _omitNulls
      [ "minRecommendedVersion" .= clientVersionsConfigDTOMinRecommendedVersion
      , "minCompatibleVersion" .= clientVersionsConfigDTOMinCompatibleVersion
      , "maxCompatibleVersion" .= clientVersionsConfigDTOMaxCompatibleVersion
      ]


-- | Construct a value of type 'ClientVersionsConfigDTO' (by applying it's required fields, if any)
mkClientVersionsConfigDTO
  :: ClientVersionsConfigDTO
mkClientVersionsConfigDTO =
  ClientVersionsConfigDTO
  { clientVersionsConfigDTOMinRecommendedVersion = Nothing
  , clientVersionsConfigDTOMinCompatibleVersion = Nothing
  , clientVersionsConfigDTOMaxCompatibleVersion = Nothing
  }

-- ** CompletedExperimentParams
-- | CompletedExperimentParams
data CompletedExperimentParams = CompletedExperimentParams
    { completedExperimentParamsState     :: !(ExperimentState) -- ^ /Required/ "state"
    -- ^ /Required/ "traceback"
    , completedExperimentParamsTraceback :: !(Text) -- ^ /Required/ "traceback"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CompletedExperimentParams
instance A.FromJSON CompletedExperimentParams where
  parseJSON = A.withObject "CompletedExperimentParams" $ \o ->
    CompletedExperimentParams
      <$> (o .:  "state")
      <*> (o .:  "traceback")

-- | ToJSON CompletedExperimentParams
instance A.ToJSON CompletedExperimentParams where
  toJSON CompletedExperimentParams {..} =
   _omitNulls
      [ "state" .= completedExperimentParamsState
      , "traceback" .= completedExperimentParamsTraceback
      ]


-- | Construct a value of type 'CompletedExperimentParams' (by applying it's required fields, if any)
mkCompletedExperimentParams
  :: ExperimentState -- ^ 'completedExperimentParamsState'
  -> Text -- ^ 'completedExperimentParamsTraceback'
  -> CompletedExperimentParams
mkCompletedExperimentParams completedExperimentParamsState completedExperimentParamsTraceback =
  CompletedExperimentParams
  { completedExperimentParamsState
  , completedExperimentParamsTraceback
  }

-- ** ComponentStatus
-- | ComponentStatus
data ComponentStatus = ComponentStatus
    { componentStatusName   :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "status"
    , componentStatusStatus :: !(Text) -- ^ /Required/ "status"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComponentStatus
instance A.FromJSON ComponentStatus where
  parseJSON = A.withObject "ComponentStatus" $ \o ->
    ComponentStatus
      <$> (o .:  "name")
      <*> (o .:  "status")

-- | ToJSON ComponentStatus
instance A.ToJSON ComponentStatus where
  toJSON ComponentStatus {..} =
   _omitNulls
      [ "name" .= componentStatusName
      , "status" .= componentStatusStatus
      ]


-- | Construct a value of type 'ComponentStatus' (by applying it's required fields, if any)
mkComponentStatus
  :: Text -- ^ 'componentStatusName'
  -> Text -- ^ 'componentStatusStatus'
  -> ComponentStatus
mkComponentStatus componentStatusName componentStatusStatus =
  ComponentStatus
  { componentStatusName
  , componentStatusStatus
  }

-- ** ComponentVersion
-- | ComponentVersion
data ComponentVersion = ComponentVersion
    { componentVersionName    :: !(NameEnum) -- ^ /Required/ "name"
    -- ^ /Required/ "version"
    , componentVersionVersion :: !(Text) -- ^ /Required/ "version"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComponentVersion
instance A.FromJSON ComponentVersion where
  parseJSON = A.withObject "ComponentVersion" $ \o ->
    ComponentVersion
      <$> (o .:  "name")
      <*> (o .:  "version")

-- | ToJSON ComponentVersion
instance A.ToJSON ComponentVersion where
  toJSON ComponentVersion {..} =
   _omitNulls
      [ "name" .= componentVersionName
      , "version" .= componentVersionVersion
      ]


-- | Construct a value of type 'ComponentVersion' (by applying it's required fields, if any)
mkComponentVersion
  :: NameEnum -- ^ 'componentVersionName'
  -> Text -- ^ 'componentVersionVersion'
  -> ComponentVersion
mkComponentVersion componentVersionName componentVersionVersion =
  ComponentVersion
  { componentVersionName
  , componentVersionVersion
  }

-- ** ConfigInfo
-- | ConfigInfo
data ConfigInfo = ConfigInfo
    { configInfoMaxFormContentSize :: !(Int) -- ^ /Required/ "maxFormContentSize"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfigInfo
instance A.FromJSON ConfigInfo where
  parseJSON = A.withObject "ConfigInfo" $ \o ->
    ConfigInfo
      <$> (o .:  "maxFormContentSize")

-- | ToJSON ConfigInfo
instance A.ToJSON ConfigInfo where
  toJSON ConfigInfo {..} =
   _omitNulls
      [ "maxFormContentSize" .= configInfoMaxFormContentSize
      ]


-- | Construct a value of type 'ConfigInfo' (by applying it's required fields, if any)
mkConfigInfo
  :: Int -- ^ 'configInfoMaxFormContentSize'
  -> ConfigInfo
mkConfigInfo configInfoMaxFormContentSize =
  ConfigInfo
  { configInfoMaxFormContentSize
  }

-- ** CreateSessionParamsDTO
-- | CreateSessionParamsDTO
-- Stripe Checkout Session details
data CreateSessionParamsDTO = CreateSessionParamsDTO
    { createSessionParamsDTOSuccessUrl :: !(Text) -- ^ /Required/ "successUrl"
    -- ^ /Required/ "failureUrl"
    , createSessionParamsDTOFailureUrl :: !(Text) -- ^ /Required/ "failureUrl"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSessionParamsDTO
instance A.FromJSON CreateSessionParamsDTO where
  parseJSON = A.withObject "CreateSessionParamsDTO" $ \o ->
    CreateSessionParamsDTO
      <$> (o .:  "successUrl")
      <*> (o .:  "failureUrl")

-- | ToJSON CreateSessionParamsDTO
instance A.ToJSON CreateSessionParamsDTO where
  toJSON CreateSessionParamsDTO {..} =
   _omitNulls
      [ "successUrl" .= createSessionParamsDTOSuccessUrl
      , "failureUrl" .= createSessionParamsDTOFailureUrl
      ]


-- | Construct a value of type 'CreateSessionParamsDTO' (by applying it's required fields, if any)
mkCreateSessionParamsDTO
  :: Text -- ^ 'createSessionParamsDTOSuccessUrl'
  -> Text -- ^ 'createSessionParamsDTOFailureUrl'
  -> CreateSessionParamsDTO
mkCreateSessionParamsDTO createSessionParamsDTOSuccessUrl createSessionParamsDTOFailureUrl =
  CreateSessionParamsDTO
  { createSessionParamsDTOSuccessUrl
  , createSessionParamsDTOFailureUrl
  }

-- ** CustomerDTO
-- | CustomerDTO
data CustomerDTO = CustomerDTO
    { customerDTONumberOfUsers    :: !(Maybe Integer) -- ^ "numberOfUsers"
    -- ^ /Required/ "userPriceInCents"
    , customerDTOUserPriceInCents :: !(Integer) -- ^ /Required/ "userPriceInCents"
    -- ^ /Required/ "pricingPlan"
    , customerDTOPricingPlan      :: !(PricingPlanDTO) -- ^ /Required/ "pricingPlan"
    -- ^ "discount"
    , customerDTODiscount         :: !(Maybe DiscountDTO) -- ^ "discount"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomerDTO
instance A.FromJSON CustomerDTO where
  parseJSON = A.withObject "CustomerDTO" $ \o ->
    CustomerDTO
      <$> (o .:? "numberOfUsers")
      <*> (o .:  "userPriceInCents")
      <*> (o .:  "pricingPlan")
      <*> (o .:? "discount")

-- | ToJSON CustomerDTO
instance A.ToJSON CustomerDTO where
  toJSON CustomerDTO {..} =
   _omitNulls
      [ "numberOfUsers" .= customerDTONumberOfUsers
      , "userPriceInCents" .= customerDTOUserPriceInCents
      , "pricingPlan" .= customerDTOPricingPlan
      , "discount" .= customerDTODiscount
      ]


-- | Construct a value of type 'CustomerDTO' (by applying it's required fields, if any)
mkCustomerDTO
  :: Integer -- ^ 'customerDTOUserPriceInCents'
  -> PricingPlanDTO -- ^ 'customerDTOPricingPlan'
  -> CustomerDTO
mkCustomerDTO customerDTOUserPriceInCents customerDTOPricingPlan =
  CustomerDTO
  { customerDTONumberOfUsers = Nothing
  , customerDTOUserPriceInCents
  , customerDTOPricingPlan
  , customerDTODiscount = Nothing
  }

-- ** DiscountCodeDTO
-- | DiscountCodeDTO
data DiscountCodeDTO = DiscountCodeDTO
    { discountCodeDTOCode :: !(Text) -- ^ /Required/ "code"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DiscountCodeDTO
instance A.FromJSON DiscountCodeDTO where
  parseJSON = A.withObject "DiscountCodeDTO" $ \o ->
    DiscountCodeDTO
      <$> (o .:  "code")

-- | ToJSON DiscountCodeDTO
instance A.ToJSON DiscountCodeDTO where
  toJSON DiscountCodeDTO {..} =
   _omitNulls
      [ "code" .= discountCodeDTOCode
      ]


-- | Construct a value of type 'DiscountCodeDTO' (by applying it's required fields, if any)
mkDiscountCodeDTO
  :: Text -- ^ 'discountCodeDTOCode'
  -> DiscountCodeDTO
mkDiscountCodeDTO discountCodeDTOCode =
  DiscountCodeDTO
  { discountCodeDTOCode
  }

-- ** DiscountDTO
-- | DiscountDTO
data DiscountDTO = DiscountDTO
    { discountDTOAmountOffPercentage :: !(Maybe Integer) -- ^ "amountOffPercentage"
    -- ^ "amountOffInCents"
    , discountDTOAmountOffInCents    :: !(Maybe Integer) -- ^ "amountOffInCents"
    -- ^ "end"
    , discountDTOEnd                 :: !(Maybe DateTime) -- ^ "end"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DiscountDTO
instance A.FromJSON DiscountDTO where
  parseJSON = A.withObject "DiscountDTO" $ \o ->
    DiscountDTO
      <$> (o .:? "amountOffPercentage")
      <*> (o .:? "amountOffInCents")
      <*> (o .:? "end")

-- | ToJSON DiscountDTO
instance A.ToJSON DiscountDTO where
  toJSON DiscountDTO {..} =
   _omitNulls
      [ "amountOffPercentage" .= discountDTOAmountOffPercentage
      , "amountOffInCents" .= discountDTOAmountOffInCents
      , "end" .= discountDTOEnd
      ]


-- | Construct a value of type 'DiscountDTO' (by applying it's required fields, if any)
mkDiscountDTO
  :: DiscountDTO
mkDiscountDTO =
  DiscountDTO
  { discountDTOAmountOffPercentage = Nothing
  , discountDTOAmountOffInCents = Nothing
  , discountDTOEnd = Nothing
  }

-- ** DownloadPrepareRequestDTO
-- | DownloadPrepareRequestDTO
data DownloadPrepareRequestDTO = DownloadPrepareRequestDTO
    { downloadPrepareRequestDTOId          :: !(Text) -- ^ /Required/ "id"
    -- ^ "downloadUrl"
    , downloadPrepareRequestDTODownloadUrl :: !(Maybe Text) -- ^ "downloadUrl"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DownloadPrepareRequestDTO
instance A.FromJSON DownloadPrepareRequestDTO where
  parseJSON = A.withObject "DownloadPrepareRequestDTO" $ \o ->
    DownloadPrepareRequestDTO
      <$> (o .:  "id")
      <*> (o .:? "downloadUrl")

-- | ToJSON DownloadPrepareRequestDTO
instance A.ToJSON DownloadPrepareRequestDTO where
  toJSON DownloadPrepareRequestDTO {..} =
   _omitNulls
      [ "id" .= downloadPrepareRequestDTOId
      , "downloadUrl" .= downloadPrepareRequestDTODownloadUrl
      ]


-- | Construct a value of type 'DownloadPrepareRequestDTO' (by applying it's required fields, if any)
mkDownloadPrepareRequestDTO
  :: Text -- ^ 'downloadPrepareRequestDTOId'
  -> DownloadPrepareRequestDTO
mkDownloadPrepareRequestDTO downloadPrepareRequestDTOId =
  DownloadPrepareRequestDTO
  { downloadPrepareRequestDTOId
  , downloadPrepareRequestDTODownloadUrl = Nothing
  }

-- ** EditExperimentParams
-- | EditExperimentParams
data EditExperimentParams = EditExperimentParams
    { editExperimentParamsName        :: !(Maybe Text) -- ^ "name"
    -- ^ "description"
    , editExperimentParamsDescription :: !(Maybe Text) -- ^ "description"
    -- ^ "tags"
    , editExperimentParamsTags        :: !(Maybe [Text]) -- ^ "tags"
    -- ^ "properties"
    , editExperimentParamsProperties  :: !(Maybe [KeyValueProperty]) -- ^ "properties"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditExperimentParams
instance A.FromJSON EditExperimentParams where
  parseJSON = A.withObject "EditExperimentParams" $ \o ->
    EditExperimentParams
      <$> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "tags")
      <*> (o .:? "properties")

-- | ToJSON EditExperimentParams
instance A.ToJSON EditExperimentParams where
  toJSON EditExperimentParams {..} =
   _omitNulls
      [ "name" .= editExperimentParamsName
      , "description" .= editExperimentParamsDescription
      , "tags" .= editExperimentParamsTags
      , "properties" .= editExperimentParamsProperties
      ]


-- | Construct a value of type 'EditExperimentParams' (by applying it's required fields, if any)
mkEditExperimentParams
  :: EditExperimentParams
mkEditExperimentParams =
  EditExperimentParams
  { editExperimentParamsName = Nothing
  , editExperimentParamsDescription = Nothing
  , editExperimentParamsTags = Nothing
  , editExperimentParamsProperties = Nothing
  }

-- ** Error
-- | Error
data Error = Error
    { errorCode    :: !(Int) -- ^ /Required/ "code"
    -- ^ /Required/ "message"
    , errorMessage :: !(Text) -- ^ /Required/ "message"
    -- ^ "type"
    , errorType    :: !(Maybe ApiErrorTypeDTO) -- ^ "type"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:  "code")
      <*> (o .:  "message")
      <*> (o .:? "type")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "code" .= errorCode
      , "message" .= errorMessage
      , "type" .= errorType
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Int -- ^ 'errorCode'
  -> Text -- ^ 'errorMessage'
  -> Error
mkError errorCode errorMessage =
  Error
  { errorCode
  , errorMessage
  , errorType = Nothing
  }

-- ** Experiment
-- | Experiment
data Experiment = Experiment
    { experimentChannels           :: !(Maybe [Channel]) -- ^ "channels"
    -- ^ "state"
    , experimentState              :: !(Maybe ExperimentState) -- ^ "state"
    -- ^ "timeOfCompletion"
    , experimentTimeOfCompletion   :: !(Maybe DateTime) -- ^ "timeOfCompletion"
    -- ^ "checkpointId"
    , experimentCheckpointId       :: !(Maybe Text) -- ^ "checkpointId"
    -- ^ "paths"
    , experimentPaths              :: !(Maybe ExperimentPaths) -- ^ "paths"
    -- ^ "responding"
    , experimentResponding         :: !(Maybe Bool) -- ^ "responding"
    -- ^ "organizationId"
    , experimentOrganizationId     :: !(Maybe Text) -- ^ "organizationId"
    -- ^ "stateTransitions"
    , experimentStateTransitions   :: !(Maybe StateTransitions) -- ^ "stateTransitions"
    -- ^ "parameters"
    , experimentParameters         :: !(Maybe [Parameter]) -- ^ "parameters"
    -- ^ "channelsLastValues"
    , experimentChannelsLastValues :: !(Maybe [ChannelWithValue]) -- ^ "channelsLastValues"
    -- ^ "storageSize"
    , experimentStorageSize        :: !(Maybe Integer) -- ^ "storageSize"
    -- ^ "name"
    , experimentName               :: !(Maybe Text) -- ^ "name"
    -- ^ "notebookId"
    , experimentNotebookId         :: !(Maybe Text) -- ^ "notebookId"
    -- ^ "projectName"
    , experimentProjectName        :: !(Maybe Text) -- ^ "projectName"
    -- ^ "hostname"
    , experimentHostname           :: !(Maybe Text) -- ^ "hostname"
    -- ^ "trashed"
    , experimentTrashed            :: !(Maybe Bool) -- ^ "trashed"
    -- ^ "description"
    , experimentDescription        :: !(Maybe Text) -- ^ "description"
    -- ^ "tags"
    , experimentTags               :: !(Maybe [Text]) -- ^ "tags"
    -- ^ "channelsSize"
    , experimentChannelsSize       :: !(Maybe Integer) -- ^ "channelsSize"
    -- ^ "timeOfCreation"
    , experimentTimeOfCreation     :: !(Maybe DateTime) -- ^ "timeOfCreation"
    -- ^ "projectId"
    , experimentProjectId          :: !(Maybe Text) -- ^ "projectId"
    -- ^ "organizationName"
    , experimentOrganizationName   :: !(Maybe Text) -- ^ "organizationName"
    -- ^ "isCodeAccessible"
    , experimentIsCodeAccessible   :: !(Maybe Bool) -- ^ "isCodeAccessible"
    -- ^ "traceback"
    , experimentTraceback          :: !(Maybe Text) -- ^ "traceback"
    -- ^ "entrypoint"
    , experimentEntrypoint         :: !(Maybe Text) -- ^ "entrypoint"
    -- ^ "runningTime"
    , experimentRunningTime        :: !(Maybe Integer) -- ^ "runningTime"
    -- ^ /Required/ "id"
    , experimentId                 :: !(Text) -- ^ /Required/ "id"
    -- ^ "inputs"
    , experimentInputs             :: !(Maybe [InputMetadata]) -- ^ "inputs"
    -- ^ "properties"
    , experimentProperties         :: !(Maybe [KeyValueProperty]) -- ^ "properties"
    -- ^ /Required/ "shortId"
    , experimentShortId            :: !(Text) -- ^ /Required/ "shortId"
    -- ^ "componentsVersions"
    , experimentComponentsVersions :: !(Maybe [ComponentVersion]) -- ^ "componentsVersions"
    -- ^ "owner"
    , experimentOwner              :: !(Maybe Text) -- ^ "owner"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Experiment
instance A.FromJSON Experiment where
  parseJSON = A.withObject "Experiment" $ \o ->
    Experiment
      <$> (o .:? "channels")
      <*> (o .:? "state")
      <*> (o .:? "timeOfCompletion")
      <*> (o .:? "checkpointId")
      <*> (o .:? "paths")
      <*> (o .:? "responding")
      <*> (o .:? "organizationId")
      <*> (o .:? "stateTransitions")
      <*> (o .:? "parameters")
      <*> (o .:? "channelsLastValues")
      <*> (o .:? "storageSize")
      <*> (o .:? "name")
      <*> (o .:? "notebookId")
      <*> (o .:? "projectName")
      <*> (o .:? "hostname")
      <*> (o .:? "trashed")
      <*> (o .:? "description")
      <*> (o .:? "tags")
      <*> (o .:? "channelsSize")
      <*> (o .:? "timeOfCreation")
      <*> (o .:? "projectId")
      <*> (o .:? "organizationName")
      <*> (o .:? "isCodeAccessible")
      <*> (o .:? "traceback")
      <*> (o .:? "entrypoint")
      <*> (o .:? "runningTime")
      <*> (o .:  "id")
      <*> (o .:? "inputs")
      <*> (o .:? "properties")
      <*> (o .:  "shortId")
      <*> (o .:? "componentsVersions")
      <*> (o .:? "owner")

-- | ToJSON Experiment
instance A.ToJSON Experiment where
  toJSON Experiment {..} =
   _omitNulls
      [ "channels" .= experimentChannels
      , "state" .= experimentState
      , "timeOfCompletion" .= experimentTimeOfCompletion
      , "checkpointId" .= experimentCheckpointId
      , "paths" .= experimentPaths
      , "responding" .= experimentResponding
      , "organizationId" .= experimentOrganizationId
      , "stateTransitions" .= experimentStateTransitions
      , "parameters" .= experimentParameters
      , "channelsLastValues" .= experimentChannelsLastValues
      , "storageSize" .= experimentStorageSize
      , "name" .= experimentName
      , "notebookId" .= experimentNotebookId
      , "projectName" .= experimentProjectName
      , "hostname" .= experimentHostname
      , "trashed" .= experimentTrashed
      , "description" .= experimentDescription
      , "tags" .= experimentTags
      , "channelsSize" .= experimentChannelsSize
      , "timeOfCreation" .= experimentTimeOfCreation
      , "projectId" .= experimentProjectId
      , "organizationName" .= experimentOrganizationName
      , "isCodeAccessible" .= experimentIsCodeAccessible
      , "traceback" .= experimentTraceback
      , "entrypoint" .= experimentEntrypoint
      , "runningTime" .= experimentRunningTime
      , "id" .= experimentId
      , "inputs" .= experimentInputs
      , "properties" .= experimentProperties
      , "shortId" .= experimentShortId
      , "componentsVersions" .= experimentComponentsVersions
      , "owner" .= experimentOwner
      ]


-- | Construct a value of type 'Experiment' (by applying it's required fields, if any)
mkExperiment
  :: Text -- ^ 'experimentId'
  -> Text -- ^ 'experimentShortId'
  -> Experiment
mkExperiment experimentId experimentShortId =
  Experiment
  { experimentChannels = Nothing
  , experimentState = Nothing
  , experimentTimeOfCompletion = Nothing
  , experimentCheckpointId = Nothing
  , experimentPaths = Nothing
  , experimentResponding = Nothing
  , experimentOrganizationId = Nothing
  , experimentStateTransitions = Nothing
  , experimentParameters = Nothing
  , experimentChannelsLastValues = Nothing
  , experimentStorageSize = Nothing
  , experimentName = Nothing
  , experimentNotebookId = Nothing
  , experimentProjectName = Nothing
  , experimentHostname = Nothing
  , experimentTrashed = Nothing
  , experimentDescription = Nothing
  , experimentTags = Nothing
  , experimentChannelsSize = Nothing
  , experimentTimeOfCreation = Nothing
  , experimentProjectId = Nothing
  , experimentOrganizationName = Nothing
  , experimentIsCodeAccessible = Nothing
  , experimentTraceback = Nothing
  , experimentEntrypoint = Nothing
  , experimentRunningTime = Nothing
  , experimentId
  , experimentInputs = Nothing
  , experimentProperties = Nothing
  , experimentShortId
  , experimentComponentsVersions = Nothing
  , experimentOwner = Nothing
  }

-- ** ExperimentCreationParams
-- | ExperimentCreationParams
data ExperimentCreationParams = ExperimentCreationParams
    { experimentCreationParamsMonitored        :: !(Maybe Bool) -- ^ "monitored"
    -- ^ "hostname"
    , experimentCreationParamsHostname         :: !(Maybe Text) -- ^ "hostname"
    -- ^ "checkpointId"
    , experimentCreationParamsCheckpointId     :: !(Maybe Text) -- ^ "checkpointId"
    -- ^ /Required/ "projectId"
    , experimentCreationParamsProjectId        :: !(Text) -- ^ /Required/ "projectId"
    -- ^ "gitInfo"
    , experimentCreationParamsGitInfo          :: !(Maybe GitInfoDTO) -- ^ "gitInfo"
    -- ^ /Required/ "properties"
    , experimentCreationParamsProperties       :: !([KeyValueProperty]) -- ^ /Required/ "properties"
    -- ^ "configPath"
    , experimentCreationParamsConfigPath       :: !(Maybe Text) -- ^ "configPath"
    -- ^ /Required/ "execArgsTemplate"
    , experimentCreationParamsExecArgsTemplate :: !(Text) -- ^ /Required/ "execArgsTemplate"
    -- ^ /Required/ "parameters"
    , experimentCreationParamsParameters       :: !([Parameter]) -- ^ /Required/ "parameters"
    -- ^ /Required/ "enqueueCommand"
    , experimentCreationParamsEnqueueCommand   :: !(Text) -- ^ /Required/ "enqueueCommand"
    -- ^ /Required/ "name"
    , experimentCreationParamsName             :: !(Text) -- ^ /Required/ "name"
    -- ^ "notebookId"
    , experimentCreationParamsNotebookId       :: !(Maybe Text) -- ^ "notebookId"
    -- ^ "description"
    , experimentCreationParamsDescription      :: !(Maybe Text) -- ^ "description"
    -- ^ /Required/ "tags"
    , experimentCreationParamsTags             :: !([Text]) -- ^ /Required/ "tags"
    -- ^ "abortable"
    , experimentCreationParamsAbortable        :: !(Maybe Bool) -- ^ "abortable"
    -- ^ "entrypoint"
    , experimentCreationParamsEntrypoint       :: !(Maybe Text) -- ^ "entrypoint"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExperimentCreationParams
instance A.FromJSON ExperimentCreationParams where
  parseJSON = A.withObject "ExperimentCreationParams" $ \o ->
    ExperimentCreationParams
      <$> (o .:? "monitored")
      <*> (o .:? "hostname")
      <*> (o .:? "checkpointId")
      <*> (o .:  "projectId")
      <*> (o .:? "gitInfo")
      <*> (o .:  "properties")
      <*> (o .:? "configPath")
      <*> (o .:  "execArgsTemplate")
      <*> (o .:  "parameters")
      <*> (o .:  "enqueueCommand")
      <*> (o .:  "name")
      <*> (o .:? "notebookId")
      <*> (o .:? "description")
      <*> (o .:  "tags")
      <*> (o .:? "abortable")
      <*> (o .:? "entrypoint")

-- | ToJSON ExperimentCreationParams
instance A.ToJSON ExperimentCreationParams where
  toJSON ExperimentCreationParams {..} =
   _omitNulls
      [ "monitored" .= experimentCreationParamsMonitored
      , "hostname" .= experimentCreationParamsHostname
      , "checkpointId" .= experimentCreationParamsCheckpointId
      , "projectId" .= experimentCreationParamsProjectId
      , "gitInfo" .= experimentCreationParamsGitInfo
      , "properties" .= experimentCreationParamsProperties
      , "configPath" .= experimentCreationParamsConfigPath
      , "execArgsTemplate" .= experimentCreationParamsExecArgsTemplate
      , "parameters" .= experimentCreationParamsParameters
      , "enqueueCommand" .= experimentCreationParamsEnqueueCommand
      , "name" .= experimentCreationParamsName
      , "notebookId" .= experimentCreationParamsNotebookId
      , "description" .= experimentCreationParamsDescription
      , "tags" .= experimentCreationParamsTags
      , "abortable" .= experimentCreationParamsAbortable
      , "entrypoint" .= experimentCreationParamsEntrypoint
      ]


-- | Construct a value of type 'ExperimentCreationParams' (by applying it's required fields, if any)
mkExperimentCreationParams
  :: Text -- ^ 'experimentCreationParamsProjectId'
  -> [KeyValueProperty] -- ^ 'experimentCreationParamsProperties'
  -> Text -- ^ 'experimentCreationParamsExecArgsTemplate'
  -> [Parameter] -- ^ 'experimentCreationParamsParameters'
  -> Text -- ^ 'experimentCreationParamsEnqueueCommand'
  -> Text -- ^ 'experimentCreationParamsName'
  -> [Text] -- ^ 'experimentCreationParamsTags'
  -> ExperimentCreationParams
mkExperimentCreationParams experimentCreationParamsProjectId experimentCreationParamsProperties experimentCreationParamsExecArgsTemplate experimentCreationParamsParameters experimentCreationParamsEnqueueCommand experimentCreationParamsName experimentCreationParamsTags =
  ExperimentCreationParams
  { experimentCreationParamsMonitored = Nothing
  , experimentCreationParamsHostname = Nothing
  , experimentCreationParamsCheckpointId = Nothing
  , experimentCreationParamsProjectId
  , experimentCreationParamsGitInfo = Nothing
  , experimentCreationParamsProperties
  , experimentCreationParamsConfigPath = Nothing
  , experimentCreationParamsExecArgsTemplate
  , experimentCreationParamsParameters
  , experimentCreationParamsEnqueueCommand
  , experimentCreationParamsName
  , experimentCreationParamsNotebookId = Nothing
  , experimentCreationParamsDescription = Nothing
  , experimentCreationParamsTags
  , experimentCreationParamsAbortable = Nothing
  , experimentCreationParamsEntrypoint = Nothing
  }

-- ** ExperimentPaths
-- | ExperimentPaths
data ExperimentPaths = ExperimentPaths
    { experimentPathsOutput :: !(Text) -- ^ /Required/ "output"
    -- ^ /Required/ "source"
    , experimentPathsSource :: !(Text) -- ^ /Required/ "source"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExperimentPaths
instance A.FromJSON ExperimentPaths where
  parseJSON = A.withObject "ExperimentPaths" $ \o ->
    ExperimentPaths
      <$> (o .:  "output")
      <*> (o .:  "source")

-- | ToJSON ExperimentPaths
instance A.ToJSON ExperimentPaths where
  toJSON ExperimentPaths {..} =
   _omitNulls
      [ "output" .= experimentPathsOutput
      , "source" .= experimentPathsSource
      ]


-- | Construct a value of type 'ExperimentPaths' (by applying it's required fields, if any)
mkExperimentPaths
  :: Text -- ^ 'experimentPathsOutput'
  -> Text -- ^ 'experimentPathsSource'
  -> ExperimentPaths
mkExperimentPaths experimentPathsOutput experimentPathsSource =
  ExperimentPaths
  { experimentPathsOutput
  , experimentPathsSource
  }

-- ** ExperimentsAttributesNamesDTO
-- | ExperimentsAttributesNamesDTO
data ExperimentsAttributesNamesDTO = ExperimentsAttributesNamesDTO
    { experimentsAttributesNamesDTOTextParametersNames    :: !([Text]) -- ^ /Required/ "textParametersNames"
    -- ^ /Required/ "propertiesNames"
    , experimentsAttributesNamesDTOPropertiesNames        :: !([Text]) -- ^ /Required/ "propertiesNames"
    -- ^ /Required/ "numericChannelsNames"
    , experimentsAttributesNamesDTONumericChannelsNames   :: !([Text]) -- ^ /Required/ "numericChannelsNames"
    -- ^ /Required/ "numericParametersNames"
    , experimentsAttributesNamesDTONumericParametersNames :: !([Text]) -- ^ /Required/ "numericParametersNames"
    -- ^ /Required/ "textChannelsNames"
    , experimentsAttributesNamesDTOTextChannelsNames      :: !([Text]) -- ^ /Required/ "textChannelsNames"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExperimentsAttributesNamesDTO
instance A.FromJSON ExperimentsAttributesNamesDTO where
  parseJSON = A.withObject "ExperimentsAttributesNamesDTO" $ \o ->
    ExperimentsAttributesNamesDTO
      <$> (o .:  "textParametersNames")
      <*> (o .:  "propertiesNames")
      <*> (o .:  "numericChannelsNames")
      <*> (o .:  "numericParametersNames")
      <*> (o .:  "textChannelsNames")

-- | ToJSON ExperimentsAttributesNamesDTO
instance A.ToJSON ExperimentsAttributesNamesDTO where
  toJSON ExperimentsAttributesNamesDTO {..} =
   _omitNulls
      [ "textParametersNames" .= experimentsAttributesNamesDTOTextParametersNames
      , "propertiesNames" .= experimentsAttributesNamesDTOPropertiesNames
      , "numericChannelsNames" .= experimentsAttributesNamesDTONumericChannelsNames
      , "numericParametersNames" .= experimentsAttributesNamesDTONumericParametersNames
      , "textChannelsNames" .= experimentsAttributesNamesDTOTextChannelsNames
      ]


-- | Construct a value of type 'ExperimentsAttributesNamesDTO' (by applying it's required fields, if any)
mkExperimentsAttributesNamesDTO
  :: [Text] -- ^ 'experimentsAttributesNamesDTOTextParametersNames'
  -> [Text] -- ^ 'experimentsAttributesNamesDTOPropertiesNames'
  -> [Text] -- ^ 'experimentsAttributesNamesDTONumericChannelsNames'
  -> [Text] -- ^ 'experimentsAttributesNamesDTONumericParametersNames'
  -> [Text] -- ^ 'experimentsAttributesNamesDTOTextChannelsNames'
  -> ExperimentsAttributesNamesDTO
mkExperimentsAttributesNamesDTO experimentsAttributesNamesDTOTextParametersNames experimentsAttributesNamesDTOPropertiesNames experimentsAttributesNamesDTONumericChannelsNames experimentsAttributesNamesDTONumericParametersNames experimentsAttributesNamesDTOTextChannelsNames =
  ExperimentsAttributesNamesDTO
  { experimentsAttributesNamesDTOTextParametersNames
  , experimentsAttributesNamesDTOPropertiesNames
  , experimentsAttributesNamesDTONumericChannelsNames
  , experimentsAttributesNamesDTONumericParametersNames
  , experimentsAttributesNamesDTOTextChannelsNames
  }

-- ** File
-- | File
data File = File
    { filePath :: !(Text) -- ^ /Required/ "path"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON File
instance A.FromJSON File where
  parseJSON = A.withObject "File" $ \o ->
    File
      <$> (o .:  "path")

-- | ToJSON File
instance A.ToJSON File where
  toJSON File {..} =
   _omitNulls
      [ "path" .= filePath
      ]


-- | Construct a value of type 'File' (by applying it's required fields, if any)
mkFile
  :: Text -- ^ 'filePath'
  -> File
mkFile filePath =
  File
  { filePath
  }

-- ** GitCommitDTO
-- | GitCommitDTO
data GitCommitDTO = GitCommitDTO
    { gitCommitDTOAuthorEmail :: !(Text) -- ^ /Required/ "authorEmail"
    -- ^ /Required/ "commitId"
    , gitCommitDTOCommitId    :: !(Text) -- ^ /Required/ "commitId"
    -- ^ /Required/ "message"
    , gitCommitDTOMessage     :: !(Text) -- ^ /Required/ "message"
    -- ^ /Required/ "commitDate"
    , gitCommitDTOCommitDate  :: !(DateTime) -- ^ /Required/ "commitDate"
    -- ^ /Required/ "authorName"
    , gitCommitDTOAuthorName  :: !(Text) -- ^ /Required/ "authorName"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitCommitDTO
instance A.FromJSON GitCommitDTO where
  parseJSON = A.withObject "GitCommitDTO" $ \o ->
    GitCommitDTO
      <$> (o .:  "authorEmail")
      <*> (o .:  "commitId")
      <*> (o .:  "message")
      <*> (o .:  "commitDate")
      <*> (o .:  "authorName")

-- | ToJSON GitCommitDTO
instance A.ToJSON GitCommitDTO where
  toJSON GitCommitDTO {..} =
   _omitNulls
      [ "authorEmail" .= gitCommitDTOAuthorEmail
      , "commitId" .= gitCommitDTOCommitId
      , "message" .= gitCommitDTOMessage
      , "commitDate" .= gitCommitDTOCommitDate
      , "authorName" .= gitCommitDTOAuthorName
      ]


-- | Construct a value of type 'GitCommitDTO' (by applying it's required fields, if any)
mkGitCommitDTO
  :: Text -- ^ 'gitCommitDTOAuthorEmail'
  -> Text -- ^ 'gitCommitDTOCommitId'
  -> Text -- ^ 'gitCommitDTOMessage'
  -> DateTime -- ^ 'gitCommitDTOCommitDate'
  -> Text -- ^ 'gitCommitDTOAuthorName'
  -> GitCommitDTO
mkGitCommitDTO gitCommitDTOAuthorEmail gitCommitDTOCommitId gitCommitDTOMessage gitCommitDTOCommitDate gitCommitDTOAuthorName =
  GitCommitDTO
  { gitCommitDTOAuthorEmail
  , gitCommitDTOCommitId
  , gitCommitDTOMessage
  , gitCommitDTOCommitDate
  , gitCommitDTOAuthorName
  }

-- ** GitInfoDTO
-- | GitInfoDTO
data GitInfoDTO = GitInfoDTO
    { gitInfoDTOCurrentBranch   :: !(Maybe Text) -- ^ "currentBranch"
    -- ^ "remotes"
    , gitInfoDTORemotes         :: !(Maybe [Text]) -- ^ "remotes"
    -- ^ /Required/ "commit"
    , gitInfoDTOCommit          :: !(GitCommitDTO) -- ^ /Required/ "commit"
    -- ^ /Required/ "repositoryDirty"
    , gitInfoDTORepositoryDirty :: !(Bool) -- ^ /Required/ "repositoryDirty"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitInfoDTO
instance A.FromJSON GitInfoDTO where
  parseJSON = A.withObject "GitInfoDTO" $ \o ->
    GitInfoDTO
      <$> (o .:? "currentBranch")
      <*> (o .:? "remotes")
      <*> (o .:  "commit")
      <*> (o .:  "repositoryDirty")

-- | ToJSON GitInfoDTO
instance A.ToJSON GitInfoDTO where
  toJSON GitInfoDTO {..} =
   _omitNulls
      [ "currentBranch" .= gitInfoDTOCurrentBranch
      , "remotes" .= gitInfoDTORemotes
      , "commit" .= gitInfoDTOCommit
      , "repositoryDirty" .= gitInfoDTORepositoryDirty
      ]


-- | Construct a value of type 'GitInfoDTO' (by applying it's required fields, if any)
mkGitInfoDTO
  :: GitCommitDTO -- ^ 'gitInfoDTOCommit'
  -> Bool -- ^ 'gitInfoDTORepositoryDirty'
  -> GitInfoDTO
mkGitInfoDTO gitInfoDTOCommit gitInfoDTORepositoryDirty =
  GitInfoDTO
  { gitInfoDTOCurrentBranch = Nothing
  , gitInfoDTORemotes = Nothing
  , gitInfoDTOCommit
  , gitInfoDTORepositoryDirty
  }

-- ** GlobalConfiguration
-- | GlobalConfiguration
data GlobalConfiguration = GlobalConfiguration
    { globalConfigurationLicenseExpiration :: !(DateTime) -- ^ /Required/ "licenseExpiration"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GlobalConfiguration
instance A.FromJSON GlobalConfiguration where
  parseJSON = A.withObject "GlobalConfiguration" $ \o ->
    GlobalConfiguration
      <$> (o .:  "licenseExpiration")

-- | ToJSON GlobalConfiguration
instance A.ToJSON GlobalConfiguration where
  toJSON GlobalConfiguration {..} =
   _omitNulls
      [ "licenseExpiration" .= globalConfigurationLicenseExpiration
      ]


-- | Construct a value of type 'GlobalConfiguration' (by applying it's required fields, if any)
mkGlobalConfiguration
  :: DateTime -- ^ 'globalConfigurationLicenseExpiration'
  -> GlobalConfiguration
mkGlobalConfiguration globalConfigurationLicenseExpiration =
  GlobalConfiguration
  { globalConfigurationLicenseExpiration
  }

-- ** InputChannelValues
-- | InputChannelValues
data InputChannelValues = InputChannelValues
    { inputChannelValuesChannelId :: !(Text) -- ^ /Required/ "channelId"
    -- ^ /Required/ "values"
    , inputChannelValuesValues    :: !([Point]) -- ^ /Required/ "values"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InputChannelValues
instance A.FromJSON InputChannelValues where
  parseJSON = A.withObject "InputChannelValues" $ \o ->
    InputChannelValues
      <$> (o .:  "channelId")
      <*> (o .:  "values")

-- | ToJSON InputChannelValues
instance A.ToJSON InputChannelValues where
  toJSON InputChannelValues {..} =
   _omitNulls
      [ "channelId" .= inputChannelValuesChannelId
      , "values" .= inputChannelValuesValues
      ]


-- | Construct a value of type 'InputChannelValues' (by applying it's required fields, if any)
mkInputChannelValues
  :: Text -- ^ 'inputChannelValuesChannelId'
  -> [Point] -- ^ 'inputChannelValuesValues'
  -> InputChannelValues
mkInputChannelValues inputChannelValuesChannelId inputChannelValuesValues =
  InputChannelValues
  { inputChannelValuesChannelId
  , inputChannelValuesValues
  }

-- ** InputImageDTO
-- | InputImageDTO
data InputImageDTO = InputImageDTO
    { inputImageDTOName        :: !(Maybe Text) -- ^ "name"
    -- ^ "description"
    , inputImageDTODescription :: !(Maybe Text) -- ^ "description"
    -- ^ "data"
    , inputImageDTOData        :: !(Maybe Text) -- ^ "data"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InputImageDTO
instance A.FromJSON InputImageDTO where
  parseJSON = A.withObject "InputImageDTO" $ \o ->
    InputImageDTO
      <$> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "data")

-- | ToJSON InputImageDTO
instance A.ToJSON InputImageDTO where
  toJSON InputImageDTO {..} =
   _omitNulls
      [ "name" .= inputImageDTOName
      , "description" .= inputImageDTODescription
      , "data" .= inputImageDTOData
      ]


-- | Construct a value of type 'InputImageDTO' (by applying it's required fields, if any)
mkInputImageDTO
  :: InputImageDTO
mkInputImageDTO =
  InputImageDTO
  { inputImageDTOName = Nothing
  , inputImageDTODescription = Nothing
  , inputImageDTOData = Nothing
  }

-- ** InputMetadata
-- | InputMetadata
data InputMetadata = InputMetadata
    { inputMetadataSource      :: !(Text) -- ^ /Required/ "source"
    -- ^ /Required/ "destination"
    , inputMetadataDestination :: !(Text) -- ^ /Required/ "destination"
    -- ^ /Required/ "size"
    , inputMetadataSize        :: !(Integer) -- ^ /Required/ "size"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InputMetadata
instance A.FromJSON InputMetadata where
  parseJSON = A.withObject "InputMetadata" $ \o ->
    InputMetadata
      <$> (o .:  "source")
      <*> (o .:  "destination")
      <*> (o .:  "size")

-- | ToJSON InputMetadata
instance A.ToJSON InputMetadata where
  toJSON InputMetadata {..} =
   _omitNulls
      [ "source" .= inputMetadataSource
      , "destination" .= inputMetadataDestination
      , "size" .= inputMetadataSize
      ]


-- | Construct a value of type 'InputMetadata' (by applying it's required fields, if any)
mkInputMetadata
  :: Text -- ^ 'inputMetadataSource'
  -> Text -- ^ 'inputMetadataDestination'
  -> Integer -- ^ 'inputMetadataSize'
  -> InputMetadata
mkInputMetadata inputMetadataSource inputMetadataDestination inputMetadataSize =
  InputMetadata
  { inputMetadataSource
  , inputMetadataDestination
  , inputMetadataSize
  }

-- ** KeyValueProperty
-- | KeyValueProperty
data KeyValueProperty = KeyValueProperty
    { keyValuePropertyKey   :: !(Text) -- ^ /Required/ "key"
    -- ^ /Required/ "value"
    , keyValuePropertyValue :: !(Text) -- ^ /Required/ "value"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeyValueProperty
instance A.FromJSON KeyValueProperty where
  parseJSON = A.withObject "KeyValueProperty" $ \o ->
    KeyValueProperty
      <$> (o .:  "key")
      <*> (o .:  "value")

-- | ToJSON KeyValueProperty
instance A.ToJSON KeyValueProperty where
  toJSON KeyValueProperty {..} =
   _omitNulls
      [ "key" .= keyValuePropertyKey
      , "value" .= keyValuePropertyValue
      ]


-- | Construct a value of type 'KeyValueProperty' (by applying it's required fields, if any)
mkKeyValueProperty
  :: Text -- ^ 'keyValuePropertyKey'
  -> Text -- ^ 'keyValuePropertyValue'
  -> KeyValueProperty
mkKeyValueProperty keyValuePropertyKey keyValuePropertyValue =
  KeyValueProperty
  { keyValuePropertyKey
  , keyValuePropertyValue
  }

-- ** LimitedChannelValuesDTO
-- | LimitedChannelValuesDTO
data LimitedChannelValuesDTO = LimitedChannelValuesDTO
    { limitedChannelValuesDTOChannelId      :: !(Text) -- ^ /Required/ "channelId"
    -- ^ /Required/ "values"
    , limitedChannelValuesDTOValues         :: !([PointValueDTO]) -- ^ /Required/ "values"
    -- ^ /Required/ "totalItemCount"
    , limitedChannelValuesDTOTotalItemCount :: !(Int) -- ^ /Required/ "totalItemCount"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LimitedChannelValuesDTO
instance A.FromJSON LimitedChannelValuesDTO where
  parseJSON = A.withObject "LimitedChannelValuesDTO" $ \o ->
    LimitedChannelValuesDTO
      <$> (o .:  "channelId")
      <*> (o .:  "values")
      <*> (o .:  "totalItemCount")

-- | ToJSON LimitedChannelValuesDTO
instance A.ToJSON LimitedChannelValuesDTO where
  toJSON LimitedChannelValuesDTO {..} =
   _omitNulls
      [ "channelId" .= limitedChannelValuesDTOChannelId
      , "values" .= limitedChannelValuesDTOValues
      , "totalItemCount" .= limitedChannelValuesDTOTotalItemCount
      ]


-- | Construct a value of type 'LimitedChannelValuesDTO' (by applying it's required fields, if any)
mkLimitedChannelValuesDTO
  :: Text -- ^ 'limitedChannelValuesDTOChannelId'
  -> [PointValueDTO] -- ^ 'limitedChannelValuesDTOValues'
  -> Int -- ^ 'limitedChannelValuesDTOTotalItemCount'
  -> LimitedChannelValuesDTO
mkLimitedChannelValuesDTO limitedChannelValuesDTOChannelId limitedChannelValuesDTOValues limitedChannelValuesDTOTotalItemCount =
  LimitedChannelValuesDTO
  { limitedChannelValuesDTOChannelId
  , limitedChannelValuesDTOValues
  , limitedChannelValuesDTOTotalItemCount
  }

-- ** Link
-- | Link
data Link = Link
    { linkUrl :: !(Text) -- ^ /Required/ "url"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Link
instance A.FromJSON Link where
  parseJSON = A.withObject "Link" $ \o ->
    Link
      <$> (o .:  "url")

-- | ToJSON Link
instance A.ToJSON Link where
  toJSON Link {..} =
   _omitNulls
      [ "url" .= linkUrl
      ]


-- | Construct a value of type 'Link' (by applying it's required fields, if any)
mkLink
  :: Text -- ^ 'linkUrl'
  -> Link
mkLink linkUrl =
  Link
  { linkUrl
  }

-- ** LinkDTO
-- | LinkDTO
data LinkDTO = LinkDTO
    { linkDTOUrl :: !(Text) -- ^ /Required/ "url"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkDTO
instance A.FromJSON LinkDTO where
  parseJSON = A.withObject "LinkDTO" $ \o ->
    LinkDTO
      <$> (o .:  "url")

-- | ToJSON LinkDTO
instance A.ToJSON LinkDTO where
  toJSON LinkDTO {..} =
   _omitNulls
      [ "url" .= linkDTOUrl
      ]


-- | Construct a value of type 'LinkDTO' (by applying it's required fields, if any)
mkLinkDTO
  :: Text -- ^ 'linkDTOUrl'
  -> LinkDTO
mkLinkDTO linkDTOUrl =
  LinkDTO
  { linkDTOUrl
  }

-- ** LoginActionsListDTO
-- | LoginActionsListDTO
data LoginActionsListDTO = LoginActionsListDTO
    { loginActionsListDTORequiredActions :: !([LoginActionDTO]) -- ^ /Required/ "requiredActions"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LoginActionsListDTO
instance A.FromJSON LoginActionsListDTO where
  parseJSON = A.withObject "LoginActionsListDTO" $ \o ->
    LoginActionsListDTO
      <$> (o .:  "requiredActions")

-- | ToJSON LoginActionsListDTO
instance A.ToJSON LoginActionsListDTO where
  toJSON LoginActionsListDTO {..} =
   _omitNulls
      [ "requiredActions" .= loginActionsListDTORequiredActions
      ]


-- | Construct a value of type 'LoginActionsListDTO' (by applying it's required fields, if any)
mkLoginActionsListDTO
  :: [LoginActionDTO] -- ^ 'loginActionsListDTORequiredActions'
  -> LoginActionsListDTO
mkLoginActionsListDTO loginActionsListDTORequiredActions =
  LoginActionsListDTO
  { loginActionsListDTORequiredActions
  }

-- ** NeptuneApiToken
-- | NeptuneApiToken
data NeptuneApiToken = NeptuneApiToken
    { neptuneApiTokenToken :: !(Text) -- ^ /Required/ "token"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NeptuneApiToken
instance A.FromJSON NeptuneApiToken where
  parseJSON = A.withObject "NeptuneApiToken" $ \o ->
    NeptuneApiToken
      <$> (o .:  "token")

-- | ToJSON NeptuneApiToken
instance A.ToJSON NeptuneApiToken where
  toJSON NeptuneApiToken {..} =
   _omitNulls
      [ "token" .= neptuneApiTokenToken
      ]


-- | Construct a value of type 'NeptuneApiToken' (by applying it's required fields, if any)
mkNeptuneApiToken
  :: Text -- ^ 'neptuneApiTokenToken'
  -> NeptuneApiToken
mkNeptuneApiToken neptuneApiTokenToken =
  NeptuneApiToken
  { neptuneApiTokenToken
  }

-- ** NeptuneOauthToken
-- | NeptuneOauthToken
data NeptuneOauthToken = NeptuneOauthToken
    { neptuneOauthTokenAccessToken  :: !(Text) -- ^ /Required/ "accessToken"
    -- ^ /Required/ "refreshToken"
    , neptuneOauthTokenRefreshToken :: !(Text) -- ^ /Required/ "refreshToken"
    -- ^ /Required/ "username"
    , neptuneOauthTokenUsername     :: !(Text) -- ^ /Required/ "username"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NeptuneOauthToken
instance A.FromJSON NeptuneOauthToken where
  parseJSON = A.withObject "NeptuneOauthToken" $ \o ->
    NeptuneOauthToken
      <$> (o .:  "accessToken")
      <*> (o .:  "refreshToken")
      <*> (o .:  "username")

-- | ToJSON NeptuneOauthToken
instance A.ToJSON NeptuneOauthToken where
  toJSON NeptuneOauthToken {..} =
   _omitNulls
      [ "accessToken" .= neptuneOauthTokenAccessToken
      , "refreshToken" .= neptuneOauthTokenRefreshToken
      , "username" .= neptuneOauthTokenUsername
      ]


-- | Construct a value of type 'NeptuneOauthToken' (by applying it's required fields, if any)
mkNeptuneOauthToken
  :: Text -- ^ 'neptuneOauthTokenAccessToken'
  -> Text -- ^ 'neptuneOauthTokenRefreshToken'
  -> Text -- ^ 'neptuneOauthTokenUsername'
  -> NeptuneOauthToken
mkNeptuneOauthToken neptuneOauthTokenAccessToken neptuneOauthTokenRefreshToken neptuneOauthTokenUsername =
  NeptuneOauthToken
  { neptuneOauthTokenAccessToken
  , neptuneOauthTokenRefreshToken
  , neptuneOauthTokenUsername
  }

-- ** NewOrganizationInvitationDTO
-- | NewOrganizationInvitationDTO
data NewOrganizationInvitationDTO = NewOrganizationInvitationDTO
    { newOrganizationInvitationDTORoleGrant :: !(OrganizationRoleDTO) -- ^ /Required/ "roleGrant"
    -- ^ /Required/ "addToAllProjects"
    , newOrganizationInvitationDTOAddToAllProjects :: !(Bool) -- ^ /Required/ "addToAllProjects"
    -- ^ /Required/ "organizationIdentifier"
    , newOrganizationInvitationDTOOrganizationIdentifier :: !(Text) -- ^ /Required/ "organizationIdentifier"
    -- ^ /Required/ "invitee"
    , newOrganizationInvitationDTOInvitee :: !(Text) -- ^ /Required/ "invitee"
    -- ^ /Required/ "invitationType"
    , newOrganizationInvitationDTOInvitationType :: !(InvitationTypeEnumDTO) -- ^ /Required/ "invitationType"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewOrganizationInvitationDTO
instance A.FromJSON NewOrganizationInvitationDTO where
  parseJSON = A.withObject "NewOrganizationInvitationDTO" $ \o ->
    NewOrganizationInvitationDTO
      <$> (o .:  "roleGrant")
      <*> (o .:  "addToAllProjects")
      <*> (o .:  "organizationIdentifier")
      <*> (o .:  "invitee")
      <*> (o .:  "invitationType")

-- | ToJSON NewOrganizationInvitationDTO
instance A.ToJSON NewOrganizationInvitationDTO where
  toJSON NewOrganizationInvitationDTO {..} =
   _omitNulls
      [ "roleGrant" .= newOrganizationInvitationDTORoleGrant
      , "addToAllProjects" .= newOrganizationInvitationDTOAddToAllProjects
      , "organizationIdentifier" .= newOrganizationInvitationDTOOrganizationIdentifier
      , "invitee" .= newOrganizationInvitationDTOInvitee
      , "invitationType" .= newOrganizationInvitationDTOInvitationType
      ]


-- | Construct a value of type 'NewOrganizationInvitationDTO' (by applying it's required fields, if any)
mkNewOrganizationInvitationDTO
  :: OrganizationRoleDTO -- ^ 'newOrganizationInvitationDTORoleGrant'
  -> Bool -- ^ 'newOrganizationInvitationDTOAddToAllProjects'
  -> Text -- ^ 'newOrganizationInvitationDTOOrganizationIdentifier'
  -> Text -- ^ 'newOrganizationInvitationDTOInvitee'
  -> InvitationTypeEnumDTO -- ^ 'newOrganizationInvitationDTOInvitationType'
  -> NewOrganizationInvitationDTO
mkNewOrganizationInvitationDTO newOrganizationInvitationDTORoleGrant newOrganizationInvitationDTOAddToAllProjects newOrganizationInvitationDTOOrganizationIdentifier newOrganizationInvitationDTOInvitee newOrganizationInvitationDTOInvitationType =
  NewOrganizationInvitationDTO
  { newOrganizationInvitationDTORoleGrant
  , newOrganizationInvitationDTOAddToAllProjects
  , newOrganizationInvitationDTOOrganizationIdentifier
  , newOrganizationInvitationDTOInvitee
  , newOrganizationInvitationDTOInvitationType
  }

-- ** NewOrganizationMemberDTO
-- | NewOrganizationMemberDTO
data NewOrganizationMemberDTO = NewOrganizationMemberDTO
    { newOrganizationMemberDTOUserId :: !(Text) -- ^ /Required/ "userId"
    -- ^ /Required/ "role"
    , newOrganizationMemberDTORole   :: !(OrganizationRoleDTO) -- ^ /Required/ "role"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewOrganizationMemberDTO
instance A.FromJSON NewOrganizationMemberDTO where
  parseJSON = A.withObject "NewOrganizationMemberDTO" $ \o ->
    NewOrganizationMemberDTO
      <$> (o .:  "userId")
      <*> (o .:  "role")

-- | ToJSON NewOrganizationMemberDTO
instance A.ToJSON NewOrganizationMemberDTO where
  toJSON NewOrganizationMemberDTO {..} =
   _omitNulls
      [ "userId" .= newOrganizationMemberDTOUserId
      , "role" .= newOrganizationMemberDTORole
      ]


-- | Construct a value of type 'NewOrganizationMemberDTO' (by applying it's required fields, if any)
mkNewOrganizationMemberDTO
  :: Text -- ^ 'newOrganizationMemberDTOUserId'
  -> OrganizationRoleDTO -- ^ 'newOrganizationMemberDTORole'
  -> NewOrganizationMemberDTO
mkNewOrganizationMemberDTO newOrganizationMemberDTOUserId newOrganizationMemberDTORole =
  NewOrganizationMemberDTO
  { newOrganizationMemberDTOUserId
  , newOrganizationMemberDTORole
  }

-- ** NewProjectDTO
-- | NewProjectDTO
data NewProjectDTO = NewProjectDTO
    { newProjectDTOName           :: !(Text) -- ^ /Required/ "name"
    -- ^ "description"
    , newProjectDTODescription    :: !(Maybe Text) -- ^ "description"
    -- ^ /Required/ "projectKey"
    , newProjectDTOProjectKey     :: !(Text) -- ^ /Required/ "projectKey"
    -- ^ /Required/ "organizationId"
    , newProjectDTOOrganizationId :: !(Text) -- ^ /Required/ "organizationId"
    -- ^ "visibility"
    , newProjectDTOVisibility     :: !(Maybe ProjectVisibilityDTO) -- ^ "visibility"
    -- ^ "displayClass"
    , newProjectDTODisplayClass   :: !(Maybe Text) -- ^ "displayClass"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewProjectDTO
instance A.FromJSON NewProjectDTO where
  parseJSON = A.withObject "NewProjectDTO" $ \o ->
    NewProjectDTO
      <$> (o .:  "name")
      <*> (o .:? "description")
      <*> (o .:  "projectKey")
      <*> (o .:  "organizationId")
      <*> (o .:? "visibility")
      <*> (o .:? "displayClass")

-- | ToJSON NewProjectDTO
instance A.ToJSON NewProjectDTO where
  toJSON NewProjectDTO {..} =
   _omitNulls
      [ "name" .= newProjectDTOName
      , "description" .= newProjectDTODescription
      , "projectKey" .= newProjectDTOProjectKey
      , "organizationId" .= newProjectDTOOrganizationId
      , "visibility" .= newProjectDTOVisibility
      , "displayClass" .= newProjectDTODisplayClass
      ]


-- | Construct a value of type 'NewProjectDTO' (by applying it's required fields, if any)
mkNewProjectDTO
  :: Text -- ^ 'newProjectDTOName'
  -> Text -- ^ 'newProjectDTOProjectKey'
  -> Text -- ^ 'newProjectDTOOrganizationId'
  -> NewProjectDTO
mkNewProjectDTO newProjectDTOName newProjectDTOProjectKey newProjectDTOOrganizationId =
  NewProjectDTO
  { newProjectDTOName
  , newProjectDTODescription = Nothing
  , newProjectDTOProjectKey
  , newProjectDTOOrganizationId
  , newProjectDTOVisibility = Nothing
  , newProjectDTODisplayClass = Nothing
  }

-- ** NewProjectInvitationDTO
-- | NewProjectInvitationDTO
data NewProjectInvitationDTO = NewProjectInvitationDTO
    { newProjectInvitationDTOProjectIdentifier :: !(Text) -- ^ /Required/ "projectIdentifier"
    -- ^ /Required/ "invitee"
    , newProjectInvitationDTOInvitee           :: !(Text) -- ^ /Required/ "invitee"
    -- ^ /Required/ "invitationType"
    , newProjectInvitationDTOInvitationType    :: !(InvitationTypeEnumDTO) -- ^ /Required/ "invitationType"
    -- ^ /Required/ "roleGrant"
    , newProjectInvitationDTORoleGrant         :: !(ProjectRoleDTO) -- ^ /Required/ "roleGrant"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewProjectInvitationDTO
instance A.FromJSON NewProjectInvitationDTO where
  parseJSON = A.withObject "NewProjectInvitationDTO" $ \o ->
    NewProjectInvitationDTO
      <$> (o .:  "projectIdentifier")
      <*> (o .:  "invitee")
      <*> (o .:  "invitationType")
      <*> (o .:  "roleGrant")

-- | ToJSON NewProjectInvitationDTO
instance A.ToJSON NewProjectInvitationDTO where
  toJSON NewProjectInvitationDTO {..} =
   _omitNulls
      [ "projectIdentifier" .= newProjectInvitationDTOProjectIdentifier
      , "invitee" .= newProjectInvitationDTOInvitee
      , "invitationType" .= newProjectInvitationDTOInvitationType
      , "roleGrant" .= newProjectInvitationDTORoleGrant
      ]


-- | Construct a value of type 'NewProjectInvitationDTO' (by applying it's required fields, if any)
mkNewProjectInvitationDTO
  :: Text -- ^ 'newProjectInvitationDTOProjectIdentifier'
  -> Text -- ^ 'newProjectInvitationDTOInvitee'
  -> InvitationTypeEnumDTO -- ^ 'newProjectInvitationDTOInvitationType'
  -> ProjectRoleDTO -- ^ 'newProjectInvitationDTORoleGrant'
  -> NewProjectInvitationDTO
mkNewProjectInvitationDTO newProjectInvitationDTOProjectIdentifier newProjectInvitationDTOInvitee newProjectInvitationDTOInvitationType newProjectInvitationDTORoleGrant =
  NewProjectInvitationDTO
  { newProjectInvitationDTOProjectIdentifier
  , newProjectInvitationDTOInvitee
  , newProjectInvitationDTOInvitationType
  , newProjectInvitationDTORoleGrant
  }

-- ** NewProjectMemberDTO
-- | NewProjectMemberDTO
data NewProjectMemberDTO = NewProjectMemberDTO
    { newProjectMemberDTOUserId :: !(Text) -- ^ /Required/ "userId"
    -- ^ /Required/ "role"
    , newProjectMemberDTORole   :: !(ProjectRoleDTO) -- ^ /Required/ "role"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewProjectMemberDTO
instance A.FromJSON NewProjectMemberDTO where
  parseJSON = A.withObject "NewProjectMemberDTO" $ \o ->
    NewProjectMemberDTO
      <$> (o .:  "userId")
      <*> (o .:  "role")

-- | ToJSON NewProjectMemberDTO
instance A.ToJSON NewProjectMemberDTO where
  toJSON NewProjectMemberDTO {..} =
   _omitNulls
      [ "userId" .= newProjectMemberDTOUserId
      , "role" .= newProjectMemberDTORole
      ]


-- | Construct a value of type 'NewProjectMemberDTO' (by applying it's required fields, if any)
mkNewProjectMemberDTO
  :: Text -- ^ 'newProjectMemberDTOUserId'
  -> ProjectRoleDTO -- ^ 'newProjectMemberDTORole'
  -> NewProjectMemberDTO
mkNewProjectMemberDTO newProjectMemberDTOUserId newProjectMemberDTORole =
  NewProjectMemberDTO
  { newProjectMemberDTOUserId
  , newProjectMemberDTORole
  }

-- ** NewReservationDTO
-- | NewReservationDTO
data NewReservationDTO = NewReservationDTO
    { newReservationDTOName :: !(Text) -- ^ /Required/ "name"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewReservationDTO
instance A.FromJSON NewReservationDTO where
  parseJSON = A.withObject "NewReservationDTO" $ \o ->
    NewReservationDTO
      <$> (o .:  "name")

-- | ToJSON NewReservationDTO
instance A.ToJSON NewReservationDTO where
  toJSON NewReservationDTO {..} =
   _omitNulls
      [ "name" .= newReservationDTOName
      ]


-- | Construct a value of type 'NewReservationDTO' (by applying it's required fields, if any)
mkNewReservationDTO
  :: Text -- ^ 'newReservationDTOName'
  -> NewReservationDTO
mkNewReservationDTO newReservationDTOName =
  NewReservationDTO
  { newReservationDTOName
  }

-- ** OrganizationCreationParamsDTO
-- | OrganizationCreationParamsDTO
data OrganizationCreationParamsDTO = OrganizationCreationParamsDTO
    { organizationCreationParamsDTOName             :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "organizationType"
    , organizationCreationParamsDTOOrganizationType :: !(OrganizationTypeDTO) -- ^ /Required/ "organizationType"
    -- ^ "discountCode"
    , organizationCreationParamsDTODiscountCode     :: !(Maybe DiscountCodeDTO) -- ^ "discountCode"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationCreationParamsDTO
instance A.FromJSON OrganizationCreationParamsDTO where
  parseJSON = A.withObject "OrganizationCreationParamsDTO" $ \o ->
    OrganizationCreationParamsDTO
      <$> (o .:  "name")
      <*> (o .:  "organizationType")
      <*> (o .:? "discountCode")

-- | ToJSON OrganizationCreationParamsDTO
instance A.ToJSON OrganizationCreationParamsDTO where
  toJSON OrganizationCreationParamsDTO {..} =
   _omitNulls
      [ "name" .= organizationCreationParamsDTOName
      , "organizationType" .= organizationCreationParamsDTOOrganizationType
      , "discountCode" .= organizationCreationParamsDTODiscountCode
      ]


-- | Construct a value of type 'OrganizationCreationParamsDTO' (by applying it's required fields, if any)
mkOrganizationCreationParamsDTO
  :: Text -- ^ 'organizationCreationParamsDTOName'
  -> OrganizationTypeDTO -- ^ 'organizationCreationParamsDTOOrganizationType'
  -> OrganizationCreationParamsDTO
mkOrganizationCreationParamsDTO organizationCreationParamsDTOName organizationCreationParamsDTOOrganizationType =
  OrganizationCreationParamsDTO
  { organizationCreationParamsDTOName
  , organizationCreationParamsDTOOrganizationType
  , organizationCreationParamsDTODiscountCode = Nothing
  }

-- ** OrganizationDTO
-- | OrganizationDTO
data OrganizationDTO = OrganizationDTO
    { organizationDTOName             :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "paymentStatus"
    , organizationDTOPaymentStatus    :: !(Text) -- ^ /Required/ "paymentStatus"
    -- ^ /Required/ "avatarUrl"
    , organizationDTOAvatarUrl        :: !(Text) -- ^ /Required/ "avatarUrl"
    -- ^ /Required/ "organizationType"
    , organizationDTOOrganizationType :: !(OrganizationTypeDTO) -- ^ /Required/ "organizationType"
    -- ^ /Required/ "avatarSource"
    , organizationDTOAvatarSource     :: !(AvatarSourceEnum) -- ^ /Required/ "avatarSource"
    -- ^ "info"
    , organizationDTOInfo             :: !(Maybe Text) -- ^ "info"
    -- ^ /Required/ "id"
    , organizationDTOId               :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "created"
    , organizationDTOCreated          :: !(DateTime) -- ^ /Required/ "created"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationDTO
instance A.FromJSON OrganizationDTO where
  parseJSON = A.withObject "OrganizationDTO" $ \o ->
    OrganizationDTO
      <$> (o .:  "name")
      <*> (o .:  "paymentStatus")
      <*> (o .:  "avatarUrl")
      <*> (o .:  "organizationType")
      <*> (o .:  "avatarSource")
      <*> (o .:? "info")
      <*> (o .:  "id")
      <*> (o .:  "created")

-- | ToJSON OrganizationDTO
instance A.ToJSON OrganizationDTO where
  toJSON OrganizationDTO {..} =
   _omitNulls
      [ "name" .= organizationDTOName
      , "paymentStatus" .= organizationDTOPaymentStatus
      , "avatarUrl" .= organizationDTOAvatarUrl
      , "organizationType" .= organizationDTOOrganizationType
      , "avatarSource" .= organizationDTOAvatarSource
      , "info" .= organizationDTOInfo
      , "id" .= organizationDTOId
      , "created" .= organizationDTOCreated
      ]


-- | Construct a value of type 'OrganizationDTO' (by applying it's required fields, if any)
mkOrganizationDTO
  :: Text -- ^ 'organizationDTOName'
  -> Text -- ^ 'organizationDTOPaymentStatus'
  -> Text -- ^ 'organizationDTOAvatarUrl'
  -> OrganizationTypeDTO -- ^ 'organizationDTOOrganizationType'
  -> AvatarSourceEnum -- ^ 'organizationDTOAvatarSource'
  -> Text -- ^ 'organizationDTOId'
  -> DateTime -- ^ 'organizationDTOCreated'
  -> OrganizationDTO
mkOrganizationDTO organizationDTOName organizationDTOPaymentStatus organizationDTOAvatarUrl organizationDTOOrganizationType organizationDTOAvatarSource organizationDTOId organizationDTOCreated =
  OrganizationDTO
  { organizationDTOName
  , organizationDTOPaymentStatus
  , organizationDTOAvatarUrl
  , organizationDTOOrganizationType
  , organizationDTOAvatarSource
  , organizationDTOInfo = Nothing
  , organizationDTOId
  , organizationDTOCreated
  }

-- ** OrganizationInvitationDTO
-- | OrganizationInvitationDTO
data OrganizationInvitationDTO = OrganizationInvitationDTO
    { organizationInvitationDTORoleGrant        :: !(OrganizationRoleDTO) -- ^ /Required/ "roleGrant"
    -- ^ /Required/ "invitedBy"
    , organizationInvitationDTOInvitedBy        :: !(Text) -- ^ /Required/ "invitedBy"
    -- ^ /Required/ "organizationName"
    , organizationInvitationDTOOrganizationName :: !(Text) -- ^ /Required/ "organizationName"
    -- ^ /Required/ "id"
    , organizationInvitationDTOId               :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "invitee"
    , organizationInvitationDTOInvitee          :: !(Text) -- ^ /Required/ "invitee"
    -- ^ /Required/ "status"
    , organizationInvitationDTOStatus           :: !(InvitationStatusEnumDTO) -- ^ /Required/ "status"
    -- ^ /Required/ "invitationType"
    , organizationInvitationDTOInvitationType   :: !(InvitationTypeEnumDTO) -- ^ /Required/ "invitationType"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationInvitationDTO
instance A.FromJSON OrganizationInvitationDTO where
  parseJSON = A.withObject "OrganizationInvitationDTO" $ \o ->
    OrganizationInvitationDTO
      <$> (o .:  "roleGrant")
      <*> (o .:  "invitedBy")
      <*> (o .:  "organizationName")
      <*> (o .:  "id")
      <*> (o .:  "invitee")
      <*> (o .:  "status")
      <*> (o .:  "invitationType")

-- | ToJSON OrganizationInvitationDTO
instance A.ToJSON OrganizationInvitationDTO where
  toJSON OrganizationInvitationDTO {..} =
   _omitNulls
      [ "roleGrant" .= organizationInvitationDTORoleGrant
      , "invitedBy" .= organizationInvitationDTOInvitedBy
      , "organizationName" .= organizationInvitationDTOOrganizationName
      , "id" .= organizationInvitationDTOId
      , "invitee" .= organizationInvitationDTOInvitee
      , "status" .= organizationInvitationDTOStatus
      , "invitationType" .= organizationInvitationDTOInvitationType
      ]


-- | Construct a value of type 'OrganizationInvitationDTO' (by applying it's required fields, if any)
mkOrganizationInvitationDTO
  :: OrganizationRoleDTO -- ^ 'organizationInvitationDTORoleGrant'
  -> Text -- ^ 'organizationInvitationDTOInvitedBy'
  -> Text -- ^ 'organizationInvitationDTOOrganizationName'
  -> Text -- ^ 'organizationInvitationDTOId'
  -> Text -- ^ 'organizationInvitationDTOInvitee'
  -> InvitationStatusEnumDTO -- ^ 'organizationInvitationDTOStatus'
  -> InvitationTypeEnumDTO -- ^ 'organizationInvitationDTOInvitationType'
  -> OrganizationInvitationDTO
mkOrganizationInvitationDTO organizationInvitationDTORoleGrant organizationInvitationDTOInvitedBy organizationInvitationDTOOrganizationName organizationInvitationDTOId organizationInvitationDTOInvitee organizationInvitationDTOStatus organizationInvitationDTOInvitationType =
  OrganizationInvitationDTO
  { organizationInvitationDTORoleGrant
  , organizationInvitationDTOInvitedBy
  , organizationInvitationDTOOrganizationName
  , organizationInvitationDTOId
  , organizationInvitationDTOInvitee
  , organizationInvitationDTOStatus
  , organizationInvitationDTOInvitationType
  }

-- ** OrganizationInvitationUpdateDTO
-- | OrganizationInvitationUpdateDTO
data OrganizationInvitationUpdateDTO = OrganizationInvitationUpdateDTO
    { organizationInvitationUpdateDTORoleGrant :: !(OrganizationRoleDTO) -- ^ /Required/ "roleGrant"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationInvitationUpdateDTO
instance A.FromJSON OrganizationInvitationUpdateDTO where
  parseJSON = A.withObject "OrganizationInvitationUpdateDTO" $ \o ->
    OrganizationInvitationUpdateDTO
      <$> (o .:  "roleGrant")

-- | ToJSON OrganizationInvitationUpdateDTO
instance A.ToJSON OrganizationInvitationUpdateDTO where
  toJSON OrganizationInvitationUpdateDTO {..} =
   _omitNulls
      [ "roleGrant" .= organizationInvitationUpdateDTORoleGrant
      ]


-- | Construct a value of type 'OrganizationInvitationUpdateDTO' (by applying it's required fields, if any)
mkOrganizationInvitationUpdateDTO
  :: OrganizationRoleDTO -- ^ 'organizationInvitationUpdateDTORoleGrant'
  -> OrganizationInvitationUpdateDTO
mkOrganizationInvitationUpdateDTO organizationInvitationUpdateDTORoleGrant =
  OrganizationInvitationUpdateDTO
  { organizationInvitationUpdateDTORoleGrant
  }

-- ** OrganizationLimitsDTO
-- | OrganizationLimitsDTO
data OrganizationLimitsDTO = OrganizationLimitsDTO
    { organizationLimitsDTOStorageSize           :: !(Maybe Integer) -- ^ "storageSize"
    -- ^ "privateProjectMembers"
    , organizationLimitsDTOPrivateProjectMembers :: !(Maybe Integer) -- ^ "privateProjectMembers"
    -- ^ "projectsLimit"
    , organizationLimitsDTOProjectsLimit         :: !(Maybe Integer) -- ^ "projectsLimit"
    -- ^ "membersLimit"
    , organizationLimitsDTOMembersLimit          :: !(Maybe Integer) -- ^ "membersLimit"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationLimitsDTO
instance A.FromJSON OrganizationLimitsDTO where
  parseJSON = A.withObject "OrganizationLimitsDTO" $ \o ->
    OrganizationLimitsDTO
      <$> (o .:? "storageSize")
      <*> (o .:? "privateProjectMembers")
      <*> (o .:? "projectsLimit")
      <*> (o .:? "membersLimit")

-- | ToJSON OrganizationLimitsDTO
instance A.ToJSON OrganizationLimitsDTO where
  toJSON OrganizationLimitsDTO {..} =
   _omitNulls
      [ "storageSize" .= organizationLimitsDTOStorageSize
      , "privateProjectMembers" .= organizationLimitsDTOPrivateProjectMembers
      , "projectsLimit" .= organizationLimitsDTOProjectsLimit
      , "membersLimit" .= organizationLimitsDTOMembersLimit
      ]


-- | Construct a value of type 'OrganizationLimitsDTO' (by applying it's required fields, if any)
mkOrganizationLimitsDTO
  :: OrganizationLimitsDTO
mkOrganizationLimitsDTO =
  OrganizationLimitsDTO
  { organizationLimitsDTOStorageSize = Nothing
  , organizationLimitsDTOPrivateProjectMembers = Nothing
  , organizationLimitsDTOProjectsLimit = Nothing
  , organizationLimitsDTOMembersLimit = Nothing
  }

-- ** OrganizationMemberDTO
-- | OrganizationMemberDTO
data OrganizationMemberDTO = OrganizationMemberDTO
    { organizationMemberDTORole :: !(OrganizationRoleDTO) -- ^ /Required/ "role"
    -- ^ /Required/ "editableRole"
    , organizationMemberDTOEditableRole :: !(Bool) -- ^ /Required/ "editableRole"
    -- ^ "registeredMemberInfo"
    , organizationMemberDTORegisteredMemberInfo :: !(Maybe RegisteredMemberInfoDTO) -- ^ "registeredMemberInfo"
    -- ^ "invitationInfo"
    , organizationMemberDTOInvitationInfo :: !(Maybe OrganizationInvitationDTO) -- ^ "invitationInfo"
    -- ^ "totalNumberOfProjects"
    , organizationMemberDTOTotalNumberOfProjects :: !(Maybe Int) -- ^ "totalNumberOfProjects"
    -- ^ "numberOfProjects"
    , organizationMemberDTONumberOfProjects :: !(Maybe Int) -- ^ "numberOfProjects"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationMemberDTO
instance A.FromJSON OrganizationMemberDTO where
  parseJSON = A.withObject "OrganizationMemberDTO" $ \o ->
    OrganizationMemberDTO
      <$> (o .:  "role")
      <*> (o .:  "editableRole")
      <*> (o .:? "registeredMemberInfo")
      <*> (o .:? "invitationInfo")
      <*> (o .:? "totalNumberOfProjects")
      <*> (o .:? "numberOfProjects")

-- | ToJSON OrganizationMemberDTO
instance A.ToJSON OrganizationMemberDTO where
  toJSON OrganizationMemberDTO {..} =
   _omitNulls
      [ "role" .= organizationMemberDTORole
      , "editableRole" .= organizationMemberDTOEditableRole
      , "registeredMemberInfo" .= organizationMemberDTORegisteredMemberInfo
      , "invitationInfo" .= organizationMemberDTOInvitationInfo
      , "totalNumberOfProjects" .= organizationMemberDTOTotalNumberOfProjects
      , "numberOfProjects" .= organizationMemberDTONumberOfProjects
      ]


-- | Construct a value of type 'OrganizationMemberDTO' (by applying it's required fields, if any)
mkOrganizationMemberDTO
  :: OrganizationRoleDTO -- ^ 'organizationMemberDTORole'
  -> Bool -- ^ 'organizationMemberDTOEditableRole'
  -> OrganizationMemberDTO
mkOrganizationMemberDTO organizationMemberDTORole organizationMemberDTOEditableRole =
  OrganizationMemberDTO
  { organizationMemberDTORole
  , organizationMemberDTOEditableRole
  , organizationMemberDTORegisteredMemberInfo = Nothing
  , organizationMemberDTOInvitationInfo = Nothing
  , organizationMemberDTOTotalNumberOfProjects = Nothing
  , organizationMemberDTONumberOfProjects = Nothing
  }

-- ** OrganizationMemberUpdateDTO
-- | OrganizationMemberUpdateDTO
data OrganizationMemberUpdateDTO = OrganizationMemberUpdateDTO
    { organizationMemberUpdateDTORole :: !(OrganizationRoleDTO) -- ^ /Required/ "role"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationMemberUpdateDTO
instance A.FromJSON OrganizationMemberUpdateDTO where
  parseJSON = A.withObject "OrganizationMemberUpdateDTO" $ \o ->
    OrganizationMemberUpdateDTO
      <$> (o .:  "role")

-- | ToJSON OrganizationMemberUpdateDTO
instance A.ToJSON OrganizationMemberUpdateDTO where
  toJSON OrganizationMemberUpdateDTO {..} =
   _omitNulls
      [ "role" .= organizationMemberUpdateDTORole
      ]


-- | Construct a value of type 'OrganizationMemberUpdateDTO' (by applying it's required fields, if any)
mkOrganizationMemberUpdateDTO
  :: OrganizationRoleDTO -- ^ 'organizationMemberUpdateDTORole'
  -> OrganizationMemberUpdateDTO
mkOrganizationMemberUpdateDTO organizationMemberUpdateDTORole =
  OrganizationMemberUpdateDTO
  { organizationMemberUpdateDTORole
  }

-- ** OrganizationNameAvailableDTO
-- | OrganizationNameAvailableDTO
data OrganizationNameAvailableDTO = OrganizationNameAvailableDTO
    { organizationNameAvailableDTOAvailable :: !(Bool) -- ^ /Required/ "available"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationNameAvailableDTO
instance A.FromJSON OrganizationNameAvailableDTO where
  parseJSON = A.withObject "OrganizationNameAvailableDTO" $ \o ->
    OrganizationNameAvailableDTO
      <$> (o .:  "available")

-- | ToJSON OrganizationNameAvailableDTO
instance A.ToJSON OrganizationNameAvailableDTO where
  toJSON OrganizationNameAvailableDTO {..} =
   _omitNulls
      [ "available" .= organizationNameAvailableDTOAvailable
      ]


-- | Construct a value of type 'OrganizationNameAvailableDTO' (by applying it's required fields, if any)
mkOrganizationNameAvailableDTO
  :: Bool -- ^ 'organizationNameAvailableDTOAvailable'
  -> OrganizationNameAvailableDTO
mkOrganizationNameAvailableDTO organizationNameAvailableDTOAvailable =
  OrganizationNameAvailableDTO
  { organizationNameAvailableDTOAvailable
  }

-- ** OrganizationPricingPlanDTO
-- | OrganizationPricingPlanDTO
data OrganizationPricingPlanDTO = OrganizationPricingPlanDTO
    { organizationPricingPlanDTOPricingPlan :: !(PricingPlanDTO) -- ^ /Required/ "pricingPlan"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationPricingPlanDTO
instance A.FromJSON OrganizationPricingPlanDTO where
  parseJSON = A.withObject "OrganizationPricingPlanDTO" $ \o ->
    OrganizationPricingPlanDTO
      <$> (o .:  "pricingPlan")

-- | ToJSON OrganizationPricingPlanDTO
instance A.ToJSON OrganizationPricingPlanDTO where
  toJSON OrganizationPricingPlanDTO {..} =
   _omitNulls
      [ "pricingPlan" .= organizationPricingPlanDTOPricingPlan
      ]


-- | Construct a value of type 'OrganizationPricingPlanDTO' (by applying it's required fields, if any)
mkOrganizationPricingPlanDTO
  :: PricingPlanDTO -- ^ 'organizationPricingPlanDTOPricingPlan'
  -> OrganizationPricingPlanDTO
mkOrganizationPricingPlanDTO organizationPricingPlanDTOPricingPlan =
  OrganizationPricingPlanDTO
  { organizationPricingPlanDTOPricingPlan
  }

-- ** OrganizationUpdateDTO
-- | OrganizationUpdateDTO
data OrganizationUpdateDTO = OrganizationUpdateDTO
    { organizationUpdateDTOName :: !(Maybe Text) -- ^ "name"
    -- ^ "info"
    , organizationUpdateDTOInfo :: !(Maybe Text) -- ^ "info"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationUpdateDTO
instance A.FromJSON OrganizationUpdateDTO where
  parseJSON = A.withObject "OrganizationUpdateDTO" $ \o ->
    OrganizationUpdateDTO
      <$> (o .:? "name")
      <*> (o .:? "info")

-- | ToJSON OrganizationUpdateDTO
instance A.ToJSON OrganizationUpdateDTO where
  toJSON OrganizationUpdateDTO {..} =
   _omitNulls
      [ "name" .= organizationUpdateDTOName
      , "info" .= organizationUpdateDTOInfo
      ]


-- | Construct a value of type 'OrganizationUpdateDTO' (by applying it's required fields, if any)
mkOrganizationUpdateDTO
  :: OrganizationUpdateDTO
mkOrganizationUpdateDTO =
  OrganizationUpdateDTO
  { organizationUpdateDTOName = Nothing
  , organizationUpdateDTOInfo = Nothing
  }

-- ** OrganizationWithRoleDTO
-- | OrganizationWithRoleDTO
data OrganizationWithRoleDTO = OrganizationWithRoleDTO
    { organizationWithRoleDTOName             :: !(Text) -- ^ /Required/ "name"
    -- ^ "userRole"
    , organizationWithRoleDTOUserRole         :: !(Maybe OrganizationRoleDTO) -- ^ "userRole"
    -- ^ /Required/ "paymentStatus"
    , organizationWithRoleDTOPaymentStatus    :: !(Text) -- ^ /Required/ "paymentStatus"
    -- ^ /Required/ "avatarUrl"
    , organizationWithRoleDTOAvatarUrl        :: !(Text) -- ^ /Required/ "avatarUrl"
    -- ^ /Required/ "organizationType"
    , organizationWithRoleDTOOrganizationType :: !(OrganizationTypeDTO) -- ^ /Required/ "organizationType"
    -- ^ /Required/ "avatarSource"
    , organizationWithRoleDTOAvatarSource     :: !(AvatarSourceEnum) -- ^ /Required/ "avatarSource"
    -- ^ "info"
    , organizationWithRoleDTOInfo             :: !(Maybe Text) -- ^ "info"
    -- ^ /Required/ "id"
    , organizationWithRoleDTOId               :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "created"
    , organizationWithRoleDTOCreated          :: !(DateTime) -- ^ /Required/ "created"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationWithRoleDTO
instance A.FromJSON OrganizationWithRoleDTO where
  parseJSON = A.withObject "OrganizationWithRoleDTO" $ \o ->
    OrganizationWithRoleDTO
      <$> (o .:  "name")
      <*> (o .:? "userRole")
      <*> (o .:  "paymentStatus")
      <*> (o .:  "avatarUrl")
      <*> (o .:  "organizationType")
      <*> (o .:  "avatarSource")
      <*> (o .:? "info")
      <*> (o .:  "id")
      <*> (o .:  "created")

-- | ToJSON OrganizationWithRoleDTO
instance A.ToJSON OrganizationWithRoleDTO where
  toJSON OrganizationWithRoleDTO {..} =
   _omitNulls
      [ "name" .= organizationWithRoleDTOName
      , "userRole" .= organizationWithRoleDTOUserRole
      , "paymentStatus" .= organizationWithRoleDTOPaymentStatus
      , "avatarUrl" .= organizationWithRoleDTOAvatarUrl
      , "organizationType" .= organizationWithRoleDTOOrganizationType
      , "avatarSource" .= organizationWithRoleDTOAvatarSource
      , "info" .= organizationWithRoleDTOInfo
      , "id" .= organizationWithRoleDTOId
      , "created" .= organizationWithRoleDTOCreated
      ]


-- | Construct a value of type 'OrganizationWithRoleDTO' (by applying it's required fields, if any)
mkOrganizationWithRoleDTO
  :: Text -- ^ 'organizationWithRoleDTOName'
  -> Text -- ^ 'organizationWithRoleDTOPaymentStatus'
  -> Text -- ^ 'organizationWithRoleDTOAvatarUrl'
  -> OrganizationTypeDTO -- ^ 'organizationWithRoleDTOOrganizationType'
  -> AvatarSourceEnum -- ^ 'organizationWithRoleDTOAvatarSource'
  -> Text -- ^ 'organizationWithRoleDTOId'
  -> DateTime -- ^ 'organizationWithRoleDTOCreated'
  -> OrganizationWithRoleDTO
mkOrganizationWithRoleDTO organizationWithRoleDTOName organizationWithRoleDTOPaymentStatus organizationWithRoleDTOAvatarUrl organizationWithRoleDTOOrganizationType organizationWithRoleDTOAvatarSource organizationWithRoleDTOId organizationWithRoleDTOCreated =
  OrganizationWithRoleDTO
  { organizationWithRoleDTOName
  , organizationWithRoleDTOUserRole = Nothing
  , organizationWithRoleDTOPaymentStatus
  , organizationWithRoleDTOAvatarUrl
  , organizationWithRoleDTOOrganizationType
  , organizationWithRoleDTOAvatarSource
  , organizationWithRoleDTOInfo = Nothing
  , organizationWithRoleDTOId
  , organizationWithRoleDTOCreated
  }

-- ** OutputImageDTO
-- | OutputImageDTO
data OutputImageDTO = OutputImageDTO
    { outputImageDTOName         :: !(Maybe Text) -- ^ "name"
    -- ^ "description"
    , outputImageDTODescription  :: !(Maybe Text) -- ^ "description"
    -- ^ "imageUrl"
    , outputImageDTOImageUrl     :: !(Maybe Text) -- ^ "imageUrl"
    -- ^ "thumbnailUrl"
    , outputImageDTOThumbnailUrl :: !(Maybe Text) -- ^ "thumbnailUrl"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OutputImageDTO
instance A.FromJSON OutputImageDTO where
  parseJSON = A.withObject "OutputImageDTO" $ \o ->
    OutputImageDTO
      <$> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "imageUrl")
      <*> (o .:? "thumbnailUrl")

-- | ToJSON OutputImageDTO
instance A.ToJSON OutputImageDTO where
  toJSON OutputImageDTO {..} =
   _omitNulls
      [ "name" .= outputImageDTOName
      , "description" .= outputImageDTODescription
      , "imageUrl" .= outputImageDTOImageUrl
      , "thumbnailUrl" .= outputImageDTOThumbnailUrl
      ]


-- | Construct a value of type 'OutputImageDTO' (by applying it's required fields, if any)
mkOutputImageDTO
  :: OutputImageDTO
mkOutputImageDTO =
  OutputImageDTO
  { outputImageDTOName = Nothing
  , outputImageDTODescription = Nothing
  , outputImageDTOImageUrl = Nothing
  , outputImageDTOThumbnailUrl = Nothing
  }

-- ** Parameter
-- | Parameter
data Parameter = Parameter
    { parameterName          :: !(Text) -- ^ /Required/ "name"
    -- ^ "description"
    , parameterDescription   :: !(Maybe Text) -- ^ "description"
    -- ^ /Required/ "parameterType"
    , parameterParameterType :: !(ParameterTypeEnum) -- ^ /Required/ "parameterType"
    -- ^ /Required/ "id"
    , parameterId            :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "value"
    , parameterValue         :: !(Text) -- ^ /Required/ "value"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Parameter
instance A.FromJSON Parameter where
  parseJSON = A.withObject "Parameter" $ \o ->
    Parameter
      <$> (o .:  "name")
      <*> (o .:? "description")
      <*> (o .:  "parameterType")
      <*> (o .:  "id")
      <*> (o .:  "value")

-- | ToJSON Parameter
instance A.ToJSON Parameter where
  toJSON Parameter {..} =
   _omitNulls
      [ "name" .= parameterName
      , "description" .= parameterDescription
      , "parameterType" .= parameterParameterType
      , "id" .= parameterId
      , "value" .= parameterValue
      ]


-- | Construct a value of type 'Parameter' (by applying it's required fields, if any)
mkParameter
  :: Text -- ^ 'parameterName'
  -> ParameterTypeEnum -- ^ 'parameterParameterType'
  -> Text -- ^ 'parameterId'
  -> Text -- ^ 'parameterValue'
  -> Parameter
mkParameter parameterName parameterParameterType parameterId parameterValue =
  Parameter
  { parameterName
  , parameterDescription = Nothing
  , parameterParameterType
  , parameterId
  , parameterValue
  }

-- ** PasswordChangeDTO
-- | PasswordChangeDTO
data PasswordChangeDTO = PasswordChangeDTO
    { passwordChangeDTOCurrentPassword :: !(Text) -- ^ /Required/ "currentPassword"
    -- ^ /Required/ "newPassword"
    , passwordChangeDTONewPassword     :: !(Text) -- ^ /Required/ "newPassword"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordChangeDTO
instance A.FromJSON PasswordChangeDTO where
  parseJSON = A.withObject "PasswordChangeDTO" $ \o ->
    PasswordChangeDTO
      <$> (o .:  "currentPassword")
      <*> (o .:  "newPassword")

-- | ToJSON PasswordChangeDTO
instance A.ToJSON PasswordChangeDTO where
  toJSON PasswordChangeDTO {..} =
   _omitNulls
      [ "currentPassword" .= passwordChangeDTOCurrentPassword
      , "newPassword" .= passwordChangeDTONewPassword
      ]


-- | Construct a value of type 'PasswordChangeDTO' (by applying it's required fields, if any)
mkPasswordChangeDTO
  :: Text -- ^ 'passwordChangeDTOCurrentPassword'
  -> Text -- ^ 'passwordChangeDTONewPassword'
  -> PasswordChangeDTO
mkPasswordChangeDTO passwordChangeDTOCurrentPassword passwordChangeDTONewPassword =
  PasswordChangeDTO
  { passwordChangeDTOCurrentPassword
  , passwordChangeDTONewPassword
  }

-- ** Point
-- | Point
data Point = Point
    { pointTimestampMillis :: !(Integer) -- ^ /Required/ "timestampMillis"
    -- ^ "x"
    , pointX               :: !(Maybe Double) -- ^ "x"
    -- ^ /Required/ "y"
    , pointY               :: !(Y) -- ^ /Required/ "y"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Point
instance A.FromJSON Point where
  parseJSON = A.withObject "Point" $ \o ->
    Point
      <$> (o .:  "timestampMillis")
      <*> (o .:? "x")
      <*> (o .:  "y")

-- | ToJSON Point
instance A.ToJSON Point where
  toJSON Point {..} =
   _omitNulls
      [ "timestampMillis" .= pointTimestampMillis
      , "x" .= pointX
      , "y" .= pointY
      ]


-- | Construct a value of type 'Point' (by applying it's required fields, if any)
mkPoint
  :: Integer -- ^ 'pointTimestampMillis'
  -> Y -- ^ 'pointY'
  -> Point
mkPoint pointTimestampMillis pointY =
  Point
  { pointTimestampMillis
  , pointX = Nothing
  , pointY
  }

-- ** PointValueDTO
-- | PointValueDTO
data PointValueDTO = PointValueDTO
    { pointValueDTOTimestampMillis :: !(Integer) -- ^ /Required/ "timestampMillis"
    -- ^ /Required/ "x"
    , pointValueDTOX               :: !(Double) -- ^ /Required/ "x"
    -- ^ /Required/ "y"
    , pointValueDTOY               :: !(Y) -- ^ /Required/ "y"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PointValueDTO
instance A.FromJSON PointValueDTO where
  parseJSON = A.withObject "PointValueDTO" $ \o ->
    PointValueDTO
      <$> (o .:  "timestampMillis")
      <*> (o .:  "x")
      <*> (o .:  "y")

-- | ToJSON PointValueDTO
instance A.ToJSON PointValueDTO where
  toJSON PointValueDTO {..} =
   _omitNulls
      [ "timestampMillis" .= pointValueDTOTimestampMillis
      , "x" .= pointValueDTOX
      , "y" .= pointValueDTOY
      ]


-- | Construct a value of type 'PointValueDTO' (by applying it's required fields, if any)
mkPointValueDTO
  :: Integer -- ^ 'pointValueDTOTimestampMillis'
  -> Double -- ^ 'pointValueDTOX'
  -> Y -- ^ 'pointValueDTOY'
  -> PointValueDTO
mkPointValueDTO pointValueDTOTimestampMillis pointValueDTOX pointValueDTOY =
  PointValueDTO
  { pointValueDTOTimestampMillis
  , pointValueDTOX
  , pointValueDTOY
  }

-- ** ProjectInvitationDTO
-- | ProjectInvitationDTO
data ProjectInvitationDTO = ProjectInvitationDTO
    { projectInvitationDTORoleGrant        :: !(ProjectRoleDTO) -- ^ /Required/ "roleGrant"
    -- ^ /Required/ "projectName"
    , projectInvitationDTOProjectName      :: !(Text) -- ^ /Required/ "projectName"
    -- ^ /Required/ "invitedBy"
    , projectInvitationDTOInvitedBy        :: !(Text) -- ^ /Required/ "invitedBy"
    -- ^ /Required/ "organizationName"
    , projectInvitationDTOOrganizationName :: !(Text) -- ^ /Required/ "organizationName"
    -- ^ /Required/ "id"
    , projectInvitationDTOId               :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "invitee"
    , projectInvitationDTOInvitee          :: !(Text) -- ^ /Required/ "invitee"
    -- ^ /Required/ "status"
    , projectInvitationDTOStatus           :: !(InvitationStatusEnumDTO) -- ^ /Required/ "status"
    -- ^ /Required/ "invitationType"
    , projectInvitationDTOInvitationType   :: !(InvitationTypeEnumDTO) -- ^ /Required/ "invitationType"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectInvitationDTO
instance A.FromJSON ProjectInvitationDTO where
  parseJSON = A.withObject "ProjectInvitationDTO" $ \o ->
    ProjectInvitationDTO
      <$> (o .:  "roleGrant")
      <*> (o .:  "projectName")
      <*> (o .:  "invitedBy")
      <*> (o .:  "organizationName")
      <*> (o .:  "id")
      <*> (o .:  "invitee")
      <*> (o .:  "status")
      <*> (o .:  "invitationType")

-- | ToJSON ProjectInvitationDTO
instance A.ToJSON ProjectInvitationDTO where
  toJSON ProjectInvitationDTO {..} =
   _omitNulls
      [ "roleGrant" .= projectInvitationDTORoleGrant
      , "projectName" .= projectInvitationDTOProjectName
      , "invitedBy" .= projectInvitationDTOInvitedBy
      , "organizationName" .= projectInvitationDTOOrganizationName
      , "id" .= projectInvitationDTOId
      , "invitee" .= projectInvitationDTOInvitee
      , "status" .= projectInvitationDTOStatus
      , "invitationType" .= projectInvitationDTOInvitationType
      ]


-- | Construct a value of type 'ProjectInvitationDTO' (by applying it's required fields, if any)
mkProjectInvitationDTO
  :: ProjectRoleDTO -- ^ 'projectInvitationDTORoleGrant'
  -> Text -- ^ 'projectInvitationDTOProjectName'
  -> Text -- ^ 'projectInvitationDTOInvitedBy'
  -> Text -- ^ 'projectInvitationDTOOrganizationName'
  -> Text -- ^ 'projectInvitationDTOId'
  -> Text -- ^ 'projectInvitationDTOInvitee'
  -> InvitationStatusEnumDTO -- ^ 'projectInvitationDTOStatus'
  -> InvitationTypeEnumDTO -- ^ 'projectInvitationDTOInvitationType'
  -> ProjectInvitationDTO
mkProjectInvitationDTO projectInvitationDTORoleGrant projectInvitationDTOProjectName projectInvitationDTOInvitedBy projectInvitationDTOOrganizationName projectInvitationDTOId projectInvitationDTOInvitee projectInvitationDTOStatus projectInvitationDTOInvitationType =
  ProjectInvitationDTO
  { projectInvitationDTORoleGrant
  , projectInvitationDTOProjectName
  , projectInvitationDTOInvitedBy
  , projectInvitationDTOOrganizationName
  , projectInvitationDTOId
  , projectInvitationDTOInvitee
  , projectInvitationDTOStatus
  , projectInvitationDTOInvitationType
  }

-- ** ProjectInvitationUpdateDTO
-- | ProjectInvitationUpdateDTO
data ProjectInvitationUpdateDTO = ProjectInvitationUpdateDTO
    { projectInvitationUpdateDTORoleGrant :: !(ProjectRoleDTO) -- ^ /Required/ "roleGrant"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectInvitationUpdateDTO
instance A.FromJSON ProjectInvitationUpdateDTO where
  parseJSON = A.withObject "ProjectInvitationUpdateDTO" $ \o ->
    ProjectInvitationUpdateDTO
      <$> (o .:  "roleGrant")

-- | ToJSON ProjectInvitationUpdateDTO
instance A.ToJSON ProjectInvitationUpdateDTO where
  toJSON ProjectInvitationUpdateDTO {..} =
   _omitNulls
      [ "roleGrant" .= projectInvitationUpdateDTORoleGrant
      ]


-- | Construct a value of type 'ProjectInvitationUpdateDTO' (by applying it's required fields, if any)
mkProjectInvitationUpdateDTO
  :: ProjectRoleDTO -- ^ 'projectInvitationUpdateDTORoleGrant'
  -> ProjectInvitationUpdateDTO
mkProjectInvitationUpdateDTO projectInvitationUpdateDTORoleGrant =
  ProjectInvitationUpdateDTO
  { projectInvitationUpdateDTORoleGrant
  }

-- ** ProjectKeyDTO
-- | ProjectKeyDTO
data ProjectKeyDTO = ProjectKeyDTO
    { projectKeyDTOProposal :: !(Text) -- ^ /Required/ "proposal"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectKeyDTO
instance A.FromJSON ProjectKeyDTO where
  parseJSON = A.withObject "ProjectKeyDTO" $ \o ->
    ProjectKeyDTO
      <$> (o .:  "proposal")

-- | ToJSON ProjectKeyDTO
instance A.ToJSON ProjectKeyDTO where
  toJSON ProjectKeyDTO {..} =
   _omitNulls
      [ "proposal" .= projectKeyDTOProposal
      ]


-- | Construct a value of type 'ProjectKeyDTO' (by applying it's required fields, if any)
mkProjectKeyDTO
  :: Text -- ^ 'projectKeyDTOProposal'
  -> ProjectKeyDTO
mkProjectKeyDTO projectKeyDTOProposal =
  ProjectKeyDTO
  { projectKeyDTOProposal
  }

-- ** ProjectListDTO
-- | ProjectListDTO
data ProjectListDTO = ProjectListDTO
    { projectListDTOEntries           :: !([ProjectWithRoleDTO]) -- ^ /Required/ "entries"
    -- ^ /Required/ "matchingItemCount"
    , projectListDTOMatchingItemCount :: !(Int) -- ^ /Required/ "matchingItemCount"
    -- ^ /Required/ "totalItemCount"
    , projectListDTOTotalItemCount    :: !(Int) -- ^ /Required/ "totalItemCount"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectListDTO
instance A.FromJSON ProjectListDTO where
  parseJSON = A.withObject "ProjectListDTO" $ \o ->
    ProjectListDTO
      <$> (o .:  "entries")
      <*> (o .:  "matchingItemCount")
      <*> (o .:  "totalItemCount")

-- | ToJSON ProjectListDTO
instance A.ToJSON ProjectListDTO where
  toJSON ProjectListDTO {..} =
   _omitNulls
      [ "entries" .= projectListDTOEntries
      , "matchingItemCount" .= projectListDTOMatchingItemCount
      , "totalItemCount" .= projectListDTOTotalItemCount
      ]


-- | Construct a value of type 'ProjectListDTO' (by applying it's required fields, if any)
mkProjectListDTO
  :: [ProjectWithRoleDTO] -- ^ 'projectListDTOEntries'
  -> Int -- ^ 'projectListDTOMatchingItemCount'
  -> Int -- ^ 'projectListDTOTotalItemCount'
  -> ProjectListDTO
mkProjectListDTO projectListDTOEntries projectListDTOMatchingItemCount projectListDTOTotalItemCount =
  ProjectListDTO
  { projectListDTOEntries
  , projectListDTOMatchingItemCount
  , projectListDTOTotalItemCount
  }

-- ** ProjectMemberDTO
-- | ProjectMemberDTO
data ProjectMemberDTO = ProjectMemberDTO
    { projectMemberDTORole                 :: !(ProjectRoleDTO) -- ^ /Required/ "role"
    -- ^ "registeredMemberInfo"
    , projectMemberDTORegisteredMemberInfo :: !(Maybe RegisteredMemberInfoDTO) -- ^ "registeredMemberInfo"
    -- ^ "invitationInfo"
    , projectMemberDTOInvitationInfo       :: !(Maybe ProjectInvitationDTO) -- ^ "invitationInfo"
    -- ^ /Required/ "editableRole"
    , projectMemberDTOEditableRole         :: !(Bool) -- ^ /Required/ "editableRole"
    -- ^ /Required/ "canLeaveProject"
    , projectMemberDTOCanLeaveProject      :: !(Bool) -- ^ /Required/ "canLeaveProject"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMemberDTO
instance A.FromJSON ProjectMemberDTO where
  parseJSON = A.withObject "ProjectMemberDTO" $ \o ->
    ProjectMemberDTO
      <$> (o .:  "role")
      <*> (o .:? "registeredMemberInfo")
      <*> (o .:? "invitationInfo")
      <*> (o .:  "editableRole")
      <*> (o .:  "canLeaveProject")

-- | ToJSON ProjectMemberDTO
instance A.ToJSON ProjectMemberDTO where
  toJSON ProjectMemberDTO {..} =
   _omitNulls
      [ "role" .= projectMemberDTORole
      , "registeredMemberInfo" .= projectMemberDTORegisteredMemberInfo
      , "invitationInfo" .= projectMemberDTOInvitationInfo
      , "editableRole" .= projectMemberDTOEditableRole
      , "canLeaveProject" .= projectMemberDTOCanLeaveProject
      ]


-- | Construct a value of type 'ProjectMemberDTO' (by applying it's required fields, if any)
mkProjectMemberDTO
  :: ProjectRoleDTO -- ^ 'projectMemberDTORole'
  -> Bool -- ^ 'projectMemberDTOEditableRole'
  -> Bool -- ^ 'projectMemberDTOCanLeaveProject'
  -> ProjectMemberDTO
mkProjectMemberDTO projectMemberDTORole projectMemberDTOEditableRole projectMemberDTOCanLeaveProject =
  ProjectMemberDTO
  { projectMemberDTORole
  , projectMemberDTORegisteredMemberInfo = Nothing
  , projectMemberDTOInvitationInfo = Nothing
  , projectMemberDTOEditableRole
  , projectMemberDTOCanLeaveProject
  }

-- ** ProjectMemberUpdateDTO
-- | ProjectMemberUpdateDTO
data ProjectMemberUpdateDTO = ProjectMemberUpdateDTO
    { projectMemberUpdateDTORole :: !(ProjectRoleDTO) -- ^ /Required/ "role"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMemberUpdateDTO
instance A.FromJSON ProjectMemberUpdateDTO where
  parseJSON = A.withObject "ProjectMemberUpdateDTO" $ \o ->
    ProjectMemberUpdateDTO
      <$> (o .:  "role")

-- | ToJSON ProjectMemberUpdateDTO
instance A.ToJSON ProjectMemberUpdateDTO where
  toJSON ProjectMemberUpdateDTO {..} =
   _omitNulls
      [ "role" .= projectMemberUpdateDTORole
      ]


-- | Construct a value of type 'ProjectMemberUpdateDTO' (by applying it's required fields, if any)
mkProjectMemberUpdateDTO
  :: ProjectRoleDTO -- ^ 'projectMemberUpdateDTORole'
  -> ProjectMemberUpdateDTO
mkProjectMemberUpdateDTO projectMemberUpdateDTORole =
  ProjectMemberUpdateDTO
  { projectMemberUpdateDTORole
  }

-- ** ProjectMembersDTO
-- | ProjectMembersDTO
data ProjectMembersDTO = ProjectMembersDTO
    { projectMembersDTOProjectName      :: !(Text) -- ^ /Required/ "projectName"
    -- ^ /Required/ "projectId"
    , projectMembersDTOProjectId        :: !(Text) -- ^ /Required/ "projectId"
    -- ^ /Required/ "organizationName"
    , projectMembersDTOOrganizationName :: !(Text) -- ^ /Required/ "organizationName"
    -- ^ /Required/ "members"
    , projectMembersDTOMembers          :: !([ProjectMemberDTO]) -- ^ /Required/ "members"
    -- ^ /Required/ "organizationId"
    , projectMembersDTOOrganizationId   :: !(Text) -- ^ /Required/ "organizationId"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMembersDTO
instance A.FromJSON ProjectMembersDTO where
  parseJSON = A.withObject "ProjectMembersDTO" $ \o ->
    ProjectMembersDTO
      <$> (o .:  "projectName")
      <*> (o .:  "projectId")
      <*> (o .:  "organizationName")
      <*> (o .:  "members")
      <*> (o .:  "organizationId")

-- | ToJSON ProjectMembersDTO
instance A.ToJSON ProjectMembersDTO where
  toJSON ProjectMembersDTO {..} =
   _omitNulls
      [ "projectName" .= projectMembersDTOProjectName
      , "projectId" .= projectMembersDTOProjectId
      , "organizationName" .= projectMembersDTOOrganizationName
      , "members" .= projectMembersDTOMembers
      , "organizationId" .= projectMembersDTOOrganizationId
      ]


-- | Construct a value of type 'ProjectMembersDTO' (by applying it's required fields, if any)
mkProjectMembersDTO
  :: Text -- ^ 'projectMembersDTOProjectName'
  -> Text -- ^ 'projectMembersDTOProjectId'
  -> Text -- ^ 'projectMembersDTOOrganizationName'
  -> [ProjectMemberDTO] -- ^ 'projectMembersDTOMembers'
  -> Text -- ^ 'projectMembersDTOOrganizationId'
  -> ProjectMembersDTO
mkProjectMembersDTO projectMembersDTOProjectName projectMembersDTOProjectId projectMembersDTOOrganizationName projectMembersDTOMembers projectMembersDTOOrganizationId =
  ProjectMembersDTO
  { projectMembersDTOProjectName
  , projectMembersDTOProjectId
  , projectMembersDTOOrganizationName
  , projectMembersDTOMembers
  , projectMembersDTOOrganizationId
  }

-- ** ProjectMetadataDTO
-- | ProjectMetadataDTO
data ProjectMetadataDTO = ProjectMetadataDTO
    { projectMetadataDTOName             :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "organizationType"
    , projectMetadataDTOOrganizationType :: !(OrganizationTypeDTO) -- ^ /Required/ "organizationType"
    -- ^ /Required/ "timeOfCreation"
    , projectMetadataDTOTimeOfCreation   :: !(DateTime) -- ^ /Required/ "timeOfCreation"
    -- ^ /Required/ "organizationName"
    , projectMetadataDTOOrganizationName :: !(Text) -- ^ /Required/ "organizationName"
    -- ^ /Required/ "version"
    , projectMetadataDTOVersion          :: !(Int) -- ^ /Required/ "version"
    -- ^ /Required/ "id"
    , projectMetadataDTOId               :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "projectKey"
    , projectMetadataDTOProjectKey       :: !(Text) -- ^ /Required/ "projectKey"
    -- ^ /Required/ "organizationId"
    , projectMetadataDTOOrganizationId   :: !(Text) -- ^ /Required/ "organizationId"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMetadataDTO
instance A.FromJSON ProjectMetadataDTO where
  parseJSON = A.withObject "ProjectMetadataDTO" $ \o ->
    ProjectMetadataDTO
      <$> (o .:  "name")
      <*> (o .:  "organizationType")
      <*> (o .:  "timeOfCreation")
      <*> (o .:  "organizationName")
      <*> (o .:  "version")
      <*> (o .:  "id")
      <*> (o .:  "projectKey")
      <*> (o .:  "organizationId")

-- | ToJSON ProjectMetadataDTO
instance A.ToJSON ProjectMetadataDTO where
  toJSON ProjectMetadataDTO {..} =
   _omitNulls
      [ "name" .= projectMetadataDTOName
      , "organizationType" .= projectMetadataDTOOrganizationType
      , "timeOfCreation" .= projectMetadataDTOTimeOfCreation
      , "organizationName" .= projectMetadataDTOOrganizationName
      , "version" .= projectMetadataDTOVersion
      , "id" .= projectMetadataDTOId
      , "projectKey" .= projectMetadataDTOProjectKey
      , "organizationId" .= projectMetadataDTOOrganizationId
      ]


-- | Construct a value of type 'ProjectMetadataDTO' (by applying it's required fields, if any)
mkProjectMetadataDTO
  :: Text -- ^ 'projectMetadataDTOName'
  -> OrganizationTypeDTO -- ^ 'projectMetadataDTOOrganizationType'
  -> DateTime -- ^ 'projectMetadataDTOTimeOfCreation'
  -> Text -- ^ 'projectMetadataDTOOrganizationName'
  -> Int -- ^ 'projectMetadataDTOVersion'
  -> Text -- ^ 'projectMetadataDTOId'
  -> Text -- ^ 'projectMetadataDTOProjectKey'
  -> Text -- ^ 'projectMetadataDTOOrganizationId'
  -> ProjectMetadataDTO
mkProjectMetadataDTO projectMetadataDTOName projectMetadataDTOOrganizationType projectMetadataDTOTimeOfCreation projectMetadataDTOOrganizationName projectMetadataDTOVersion projectMetadataDTOId projectMetadataDTOProjectKey projectMetadataDTOOrganizationId =
  ProjectMetadataDTO
  { projectMetadataDTOName
  , projectMetadataDTOOrganizationType
  , projectMetadataDTOTimeOfCreation
  , projectMetadataDTOOrganizationName
  , projectMetadataDTOVersion
  , projectMetadataDTOId
  , projectMetadataDTOProjectKey
  , projectMetadataDTOOrganizationId
  }

-- ** ProjectUpdateDTO
-- | ProjectUpdateDTO
data ProjectUpdateDTO = ProjectUpdateDTO
    { projectUpdateDTOCodeAccess   :: !(Maybe ProjectCodeAccessDTO) -- ^ "codeAccess"
    -- ^ "name"
    , projectUpdateDTOName         :: !(Maybe Text) -- ^ "name"
    -- ^ "description"
    , projectUpdateDTODescription  :: !(Maybe Text) -- ^ "description"
    -- ^ "visibility"
    , projectUpdateDTOVisibility   :: !(Maybe ProjectVisibilityDTO) -- ^ "visibility"
    -- ^ "displayClass"
    , projectUpdateDTODisplayClass :: !(Maybe Text) -- ^ "displayClass"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectUpdateDTO
instance A.FromJSON ProjectUpdateDTO where
  parseJSON = A.withObject "ProjectUpdateDTO" $ \o ->
    ProjectUpdateDTO
      <$> (o .:? "codeAccess")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "visibility")
      <*> (o .:? "displayClass")

-- | ToJSON ProjectUpdateDTO
instance A.ToJSON ProjectUpdateDTO where
  toJSON ProjectUpdateDTO {..} =
   _omitNulls
      [ "codeAccess" .= projectUpdateDTOCodeAccess
      , "name" .= projectUpdateDTOName
      , "description" .= projectUpdateDTODescription
      , "visibility" .= projectUpdateDTOVisibility
      , "displayClass" .= projectUpdateDTODisplayClass
      ]


-- | Construct a value of type 'ProjectUpdateDTO' (by applying it's required fields, if any)
mkProjectUpdateDTO
  :: ProjectUpdateDTO
mkProjectUpdateDTO =
  ProjectUpdateDTO
  { projectUpdateDTOCodeAccess = Nothing
  , projectUpdateDTOName = Nothing
  , projectUpdateDTODescription = Nothing
  , projectUpdateDTOVisibility = Nothing
  , projectUpdateDTODisplayClass = Nothing
  }

-- ** ProjectWithRoleDTO
-- | ProjectWithRoleDTO
data ProjectWithRoleDTO = ProjectWithRoleDTO
    { projectWithRoleDTOCodeAccess             :: !(ProjectCodeAccessDTO) -- ^ /Required/ "codeAccess"
    -- ^ /Required/ "avatarUrl"
    , projectWithRoleDTOAvatarUrl              :: !(Text) -- ^ /Required/ "avatarUrl"
    -- ^ "description"
    , projectWithRoleDTODescription            :: !(Maybe Text) -- ^ "description"
    -- ^ /Required/ "organizationType"
    , projectWithRoleDTOOrganizationType       :: !(OrganizationTypeDTO) -- ^ /Required/ "organizationType"
    -- ^ /Required/ "featured"
    , projectWithRoleDTOFeatured               :: !(Bool) -- ^ /Required/ "featured"
    -- ^ /Required/ "organizationName"
    , projectWithRoleDTOOrganizationName       :: !(Text) -- ^ /Required/ "organizationName"
    -- ^ /Required/ "version"
    , projectWithRoleDTOVersion                :: !(Int) -- ^ /Required/ "version"
    -- ^ /Required/ "id"
    , projectWithRoleDTOId                     :: !(Text) -- ^ /Required/ "id"
    -- ^ /Required/ "projectKey"
    , projectWithRoleDTOProjectKey             :: !(Text) -- ^ /Required/ "projectKey"
    -- ^ /Required/ "organizationId"
    , projectWithRoleDTOOrganizationId         :: !(Text) -- ^ /Required/ "organizationId"
    -- ^ /Required/ "userCount"
    , projectWithRoleDTOUserCount              :: !(Int) -- ^ /Required/ "userCount"
    -- ^ /Required/ "visibility"
    , projectWithRoleDTOVisibility             :: !(ProjectVisibilityDTO) -- ^ /Required/ "visibility"
    -- ^ "displayClass"
    , projectWithRoleDTODisplayClass           :: !(Maybe Text) -- ^ "displayClass"
    -- ^ /Required/ "name"
    , projectWithRoleDTOName                   :: !(Text) -- ^ /Required/ "name"
    -- ^ /Required/ "lastActivity"
    , projectWithRoleDTOLastActivity           :: !(DateTime) -- ^ /Required/ "lastActivity"
    -- ^ /Required/ "timeOfCreation"
    , projectWithRoleDTOTimeOfCreation         :: !(DateTime) -- ^ /Required/ "timeOfCreation"
    -- ^ "userRoleInOrganization"
    , projectWithRoleDTOUserRoleInOrganization :: !(Maybe OrganizationRoleDTO) -- ^ "userRoleInOrganization"
    -- ^ /Required/ "avatarSource"
    , projectWithRoleDTOAvatarSource           :: !(AvatarSourceEnum) -- ^ /Required/ "avatarSource"
    -- ^ /Required/ "leaderboardEntryCount"
    , projectWithRoleDTOLeaderboardEntryCount  :: !(Int) -- ^ /Required/ "leaderboardEntryCount"
    -- ^ /Required/ "userRoleInProject"
    , projectWithRoleDTOUserRoleInProject      :: !(ProjectRoleDTO) -- ^ /Required/ "userRoleInProject"
    -- ^ "backgroundUrl"
    , projectWithRoleDTOBackgroundUrl          :: !(Maybe Text) -- ^ "backgroundUrl"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectWithRoleDTO
instance A.FromJSON ProjectWithRoleDTO where
  parseJSON = A.withObject "ProjectWithRoleDTO" $ \o ->
    ProjectWithRoleDTO
      <$> (o .:  "codeAccess")
      <*> (o .:  "avatarUrl")
      <*> (o .:? "description")
      <*> (o .:  "organizationType")
      <*> (o .:  "featured")
      <*> (o .:  "organizationName")
      <*> (o .:  "version")
      <*> (o .:  "id")
      <*> (o .:  "projectKey")
      <*> (o .:  "organizationId")
      <*> (o .:  "userCount")
      <*> (o .:  "visibility")
      <*> (o .:? "displayClass")
      <*> (o .:  "name")
      <*> (o .:  "lastActivity")
      <*> (o .:  "timeOfCreation")
      <*> (o .:? "userRoleInOrganization")
      <*> (o .:  "avatarSource")
      <*> (o .:  "leaderboardEntryCount")
      <*> (o .:  "userRoleInProject")
      <*> (o .:? "backgroundUrl")

-- | ToJSON ProjectWithRoleDTO
instance A.ToJSON ProjectWithRoleDTO where
  toJSON ProjectWithRoleDTO {..} =
   _omitNulls
      [ "codeAccess" .= projectWithRoleDTOCodeAccess
      , "avatarUrl" .= projectWithRoleDTOAvatarUrl
      , "description" .= projectWithRoleDTODescription
      , "organizationType" .= projectWithRoleDTOOrganizationType
      , "featured" .= projectWithRoleDTOFeatured
      , "organizationName" .= projectWithRoleDTOOrganizationName
      , "version" .= projectWithRoleDTOVersion
      , "id" .= projectWithRoleDTOId
      , "projectKey" .= projectWithRoleDTOProjectKey
      , "organizationId" .= projectWithRoleDTOOrganizationId
      , "userCount" .= projectWithRoleDTOUserCount
      , "visibility" .= projectWithRoleDTOVisibility
      , "displayClass" .= projectWithRoleDTODisplayClass
      , "name" .= projectWithRoleDTOName
      , "lastActivity" .= projectWithRoleDTOLastActivity
      , "timeOfCreation" .= projectWithRoleDTOTimeOfCreation
      , "userRoleInOrganization" .= projectWithRoleDTOUserRoleInOrganization
      , "avatarSource" .= projectWithRoleDTOAvatarSource
      , "leaderboardEntryCount" .= projectWithRoleDTOLeaderboardEntryCount
      , "userRoleInProject" .= projectWithRoleDTOUserRoleInProject
      , "backgroundUrl" .= projectWithRoleDTOBackgroundUrl
      ]


-- | Construct a value of type 'ProjectWithRoleDTO' (by applying it's required fields, if any)
mkProjectWithRoleDTO
  :: ProjectCodeAccessDTO -- ^ 'projectWithRoleDTOCodeAccess'
  -> Text -- ^ 'projectWithRoleDTOAvatarUrl'
  -> OrganizationTypeDTO -- ^ 'projectWithRoleDTOOrganizationType'
  -> Bool -- ^ 'projectWithRoleDTOFeatured'
  -> Text -- ^ 'projectWithRoleDTOOrganizationName'
  -> Int -- ^ 'projectWithRoleDTOVersion'
  -> Text -- ^ 'projectWithRoleDTOId'
  -> Text -- ^ 'projectWithRoleDTOProjectKey'
  -> Text -- ^ 'projectWithRoleDTOOrganizationId'
  -> Int -- ^ 'projectWithRoleDTOUserCount'
  -> ProjectVisibilityDTO -- ^ 'projectWithRoleDTOVisibility'
  -> Text -- ^ 'projectWithRoleDTOName'
  -> DateTime -- ^ 'projectWithRoleDTOLastActivity'
  -> DateTime -- ^ 'projectWithRoleDTOTimeOfCreation'
  -> AvatarSourceEnum -- ^ 'projectWithRoleDTOAvatarSource'
  -> Int -- ^ 'projectWithRoleDTOLeaderboardEntryCount'
  -> ProjectRoleDTO -- ^ 'projectWithRoleDTOUserRoleInProject'
  -> ProjectWithRoleDTO
mkProjectWithRoleDTO projectWithRoleDTOCodeAccess projectWithRoleDTOAvatarUrl projectWithRoleDTOOrganizationType projectWithRoleDTOFeatured projectWithRoleDTOOrganizationName projectWithRoleDTOVersion projectWithRoleDTOId projectWithRoleDTOProjectKey projectWithRoleDTOOrganizationId projectWithRoleDTOUserCount projectWithRoleDTOVisibility projectWithRoleDTOName projectWithRoleDTOLastActivity projectWithRoleDTOTimeOfCreation projectWithRoleDTOAvatarSource projectWithRoleDTOLeaderboardEntryCount projectWithRoleDTOUserRoleInProject =
  ProjectWithRoleDTO
  { projectWithRoleDTOCodeAccess
  , projectWithRoleDTOAvatarUrl
  , projectWithRoleDTODescription = Nothing
  , projectWithRoleDTOOrganizationType
  , projectWithRoleDTOFeatured
  , projectWithRoleDTOOrganizationName
  , projectWithRoleDTOVersion
  , projectWithRoleDTOId
  , projectWithRoleDTOProjectKey
  , projectWithRoleDTOOrganizationId
  , projectWithRoleDTOUserCount
  , projectWithRoleDTOVisibility
  , projectWithRoleDTODisplayClass = Nothing
  , projectWithRoleDTOName
  , projectWithRoleDTOLastActivity
  , projectWithRoleDTOTimeOfCreation
  , projectWithRoleDTOUserRoleInOrganization = Nothing
  , projectWithRoleDTOAvatarSource
  , projectWithRoleDTOLeaderboardEntryCount
  , projectWithRoleDTOUserRoleInProject
  , projectWithRoleDTOBackgroundUrl = Nothing
  }

-- ** PublicUserProfileDTO
-- | PublicUserProfileDTO
data PublicUserProfileDTO = PublicUserProfileDTO
    { publicUserProfileDTOBiography    :: !(Text) -- ^ /Required/ "biography"
    -- ^ "email"
    , publicUserProfileDTOEmail        :: !(Maybe Text) -- ^ "email"
    -- ^ /Required/ "avatarSource"
    , publicUserProfileDTOAvatarSource :: !(AvatarSourceEnum) -- ^ /Required/ "avatarSource"
    -- ^ "firstName"
    , publicUserProfileDTOFirstName    :: !(Maybe Text) -- ^ "firstName"
    -- ^ /Required/ "shortInfo"
    , publicUserProfileDTOShortInfo    :: !(Text) -- ^ /Required/ "shortInfo"
    -- ^ /Required/ "username"
    , publicUserProfileDTOUsername     :: !(Text) -- ^ /Required/ "username"
    -- ^ /Required/ "avatarUrl"
    , publicUserProfileDTOAvatarUrl    :: !(Text) -- ^ /Required/ "avatarUrl"
    -- ^ "lastName"
    , publicUserProfileDTOLastName     :: !(Maybe Text) -- ^ "lastName"
    -- ^ /Required/ "links"
    , publicUserProfileDTOLinks        :: !(UserProfileLinksDTO) -- ^ /Required/ "links"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PublicUserProfileDTO
instance A.FromJSON PublicUserProfileDTO where
  parseJSON = A.withObject "PublicUserProfileDTO" $ \o ->
    PublicUserProfileDTO
      <$> (o .:  "biography")
      <*> (o .:? "email")
      <*> (o .:  "avatarSource")
      <*> (o .:? "firstName")
      <*> (o .:  "shortInfo")
      <*> (o .:  "username")
      <*> (o .:  "avatarUrl")
      <*> (o .:? "lastName")
      <*> (o .:  "links")

-- | ToJSON PublicUserProfileDTO
instance A.ToJSON PublicUserProfileDTO where
  toJSON PublicUserProfileDTO {..} =
   _omitNulls
      [ "biography" .= publicUserProfileDTOBiography
      , "email" .= publicUserProfileDTOEmail
      , "avatarSource" .= publicUserProfileDTOAvatarSource
      , "firstName" .= publicUserProfileDTOFirstName
      , "shortInfo" .= publicUserProfileDTOShortInfo
      , "username" .= publicUserProfileDTOUsername
      , "avatarUrl" .= publicUserProfileDTOAvatarUrl
      , "lastName" .= publicUserProfileDTOLastName
      , "links" .= publicUserProfileDTOLinks
      ]


-- | Construct a value of type 'PublicUserProfileDTO' (by applying it's required fields, if any)
mkPublicUserProfileDTO
  :: Text -- ^ 'publicUserProfileDTOBiography'
  -> AvatarSourceEnum -- ^ 'publicUserProfileDTOAvatarSource'
  -> Text -- ^ 'publicUserProfileDTOShortInfo'
  -> Text -- ^ 'publicUserProfileDTOUsername'
  -> Text -- ^ 'publicUserProfileDTOAvatarUrl'
  -> UserProfileLinksDTO -- ^ 'publicUserProfileDTOLinks'
  -> PublicUserProfileDTO
mkPublicUserProfileDTO publicUserProfileDTOBiography publicUserProfileDTOAvatarSource publicUserProfileDTOShortInfo publicUserProfileDTOUsername publicUserProfileDTOAvatarUrl publicUserProfileDTOLinks =
  PublicUserProfileDTO
  { publicUserProfileDTOBiography
  , publicUserProfileDTOEmail = Nothing
  , publicUserProfileDTOAvatarSource
  , publicUserProfileDTOFirstName = Nothing
  , publicUserProfileDTOShortInfo
  , publicUserProfileDTOUsername
  , publicUserProfileDTOAvatarUrl
  , publicUserProfileDTOLastName = Nothing
  , publicUserProfileDTOLinks
  }

-- ** QuestionnaireDTO
-- | QuestionnaireDTO
data QuestionnaireDTO = QuestionnaireDTO
    { questionnaireDTOAnswers :: !(Text) -- ^ /Required/ "answers"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QuestionnaireDTO
instance A.FromJSON QuestionnaireDTO where
  parseJSON = A.withObject "QuestionnaireDTO" $ \o ->
    QuestionnaireDTO
      <$> (o .:  "answers")

-- | ToJSON QuestionnaireDTO
instance A.ToJSON QuestionnaireDTO where
  toJSON QuestionnaireDTO {..} =
   _omitNulls
      [ "answers" .= questionnaireDTOAnswers
      ]


-- | Construct a value of type 'QuestionnaireDTO' (by applying it's required fields, if any)
mkQuestionnaireDTO
  :: Text -- ^ 'questionnaireDTOAnswers'
  -> QuestionnaireDTO
mkQuestionnaireDTO questionnaireDTOAnswers =
  QuestionnaireDTO
  { questionnaireDTOAnswers
  }

-- ** RegisteredMemberInfoDTO
-- | RegisteredMemberInfoDTO
data RegisteredMemberInfoDTO = RegisteredMemberInfoDTO
    { registeredMemberInfoDTOAvatarSource :: !(AvatarSourceEnum) -- ^ /Required/ "avatarSource"
    -- ^ /Required/ "lastName"
    , registeredMemberInfoDTOLastName     :: !(Text) -- ^ /Required/ "lastName"
    -- ^ /Required/ "firstName"
    , registeredMemberInfoDTOFirstName    :: !(Text) -- ^ /Required/ "firstName"
    -- ^ /Required/ "username"
    , registeredMemberInfoDTOUsername     :: !(Text) -- ^ /Required/ "username"
    -- ^ /Required/ "avatarUrl"
    , registeredMemberInfoDTOAvatarUrl    :: !(Text) -- ^ /Required/ "avatarUrl"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RegisteredMemberInfoDTO
instance A.FromJSON RegisteredMemberInfoDTO where
  parseJSON = A.withObject "RegisteredMemberInfoDTO" $ \o ->
    RegisteredMemberInfoDTO
      <$> (o .:  "avatarSource")
      <*> (o .:  "lastName")
      <*> (o .:  "firstName")
      <*> (o .:  "username")
      <*> (o .:  "avatarUrl")

-- | ToJSON RegisteredMemberInfoDTO
instance A.ToJSON RegisteredMemberInfoDTO where
  toJSON RegisteredMemberInfoDTO {..} =
   _omitNulls
      [ "avatarSource" .= registeredMemberInfoDTOAvatarSource
      , "lastName" .= registeredMemberInfoDTOLastName
      , "firstName" .= registeredMemberInfoDTOFirstName
      , "username" .= registeredMemberInfoDTOUsername
      , "avatarUrl" .= registeredMemberInfoDTOAvatarUrl
      ]


-- | Construct a value of type 'RegisteredMemberInfoDTO' (by applying it's required fields, if any)
mkRegisteredMemberInfoDTO
  :: AvatarSourceEnum -- ^ 'registeredMemberInfoDTOAvatarSource'
  -> Text -- ^ 'registeredMemberInfoDTOLastName'
  -> Text -- ^ 'registeredMemberInfoDTOFirstName'
  -> Text -- ^ 'registeredMemberInfoDTOUsername'
  -> Text -- ^ 'registeredMemberInfoDTOAvatarUrl'
  -> RegisteredMemberInfoDTO
mkRegisteredMemberInfoDTO registeredMemberInfoDTOAvatarSource registeredMemberInfoDTOLastName registeredMemberInfoDTOFirstName registeredMemberInfoDTOUsername registeredMemberInfoDTOAvatarUrl =
  RegisteredMemberInfoDTO
  { registeredMemberInfoDTOAvatarSource
  , registeredMemberInfoDTOLastName
  , registeredMemberInfoDTOFirstName
  , registeredMemberInfoDTOUsername
  , registeredMemberInfoDTOAvatarUrl
  }

-- ** RegistrationSurveyDTO
-- | RegistrationSurveyDTO
data RegistrationSurveyDTO = RegistrationSurveyDTO
    { registrationSurveyDTOSurvey :: !(Text) -- ^ /Required/ "survey"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RegistrationSurveyDTO
instance A.FromJSON RegistrationSurveyDTO where
  parseJSON = A.withObject "RegistrationSurveyDTO" $ \o ->
    RegistrationSurveyDTO
      <$> (o .:  "survey")

-- | ToJSON RegistrationSurveyDTO
instance A.ToJSON RegistrationSurveyDTO where
  toJSON RegistrationSurveyDTO {..} =
   _omitNulls
      [ "survey" .= registrationSurveyDTOSurvey
      ]


-- | Construct a value of type 'RegistrationSurveyDTO' (by applying it's required fields, if any)
mkRegistrationSurveyDTO
  :: Text -- ^ 'registrationSurveyDTOSurvey'
  -> RegistrationSurveyDTO
mkRegistrationSurveyDTO registrationSurveyDTOSurvey =
  RegistrationSurveyDTO
  { registrationSurveyDTOSurvey
  }

-- ** Series
-- | Series
data Series = Series
    { seriesSeriesType  :: !(SeriesType) -- ^ /Required/ "seriesType"
    -- ^ "channelName"
    , seriesChannelName :: !(Maybe Text) -- ^ "channelName"
    -- ^ "channelId"
    , seriesChannelId   :: !(Maybe Text) -- ^ "channelId"
    -- ^ "aliasId"
    , seriesAliasId     :: !(Maybe Text) -- ^ "aliasId"
    -- ^ /Required/ "label"
    , seriesLabel       :: !(Text) -- ^ /Required/ "label"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Series
instance A.FromJSON Series where
  parseJSON = A.withObject "Series" $ \o ->
    Series
      <$> (o .:  "seriesType")
      <*> (o .:? "channelName")
      <*> (o .:? "channelId")
      <*> (o .:? "aliasId")
      <*> (o .:  "label")

-- | ToJSON Series
instance A.ToJSON Series where
  toJSON Series {..} =
   _omitNulls
      [ "seriesType" .= seriesSeriesType
      , "channelName" .= seriesChannelName
      , "channelId" .= seriesChannelId
      , "aliasId" .= seriesAliasId
      , "label" .= seriesLabel
      ]


-- | Construct a value of type 'Series' (by applying it's required fields, if any)
mkSeries
  :: SeriesType -- ^ 'seriesSeriesType'
  -> Text -- ^ 'seriesLabel'
  -> Series
mkSeries seriesSeriesType seriesLabel =
  Series
  { seriesSeriesType
  , seriesChannelName = Nothing
  , seriesChannelId = Nothing
  , seriesAliasId = Nothing
  , seriesLabel
  }

-- ** SeriesDefinition
-- | SeriesDefinition
data SeriesDefinition = SeriesDefinition
    { seriesDefinitionLabel       :: !(Text) -- ^ /Required/ "label"
    -- ^ "channelName"
    , seriesDefinitionChannelName :: !(Maybe Text) -- ^ "channelName"
    -- ^ "aliasId"
    , seriesDefinitionAliasId     :: !(Maybe Text) -- ^ "aliasId"
    -- ^ /Required/ "seriesType"
    , seriesDefinitionSeriesType  :: !(SeriesType) -- ^ /Required/ "seriesType"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SeriesDefinition
instance A.FromJSON SeriesDefinition where
  parseJSON = A.withObject "SeriesDefinition" $ \o ->
    SeriesDefinition
      <$> (o .:  "label")
      <*> (o .:? "channelName")
      <*> (o .:? "aliasId")
      <*> (o .:  "seriesType")

-- | ToJSON SeriesDefinition
instance A.ToJSON SeriesDefinition where
  toJSON SeriesDefinition {..} =
   _omitNulls
      [ "label" .= seriesDefinitionLabel
      , "channelName" .= seriesDefinitionChannelName
      , "aliasId" .= seriesDefinitionAliasId
      , "seriesType" .= seriesDefinitionSeriesType
      ]


-- | Construct a value of type 'SeriesDefinition' (by applying it's required fields, if any)
mkSeriesDefinition
  :: Text -- ^ 'seriesDefinitionLabel'
  -> SeriesType -- ^ 'seriesDefinitionSeriesType'
  -> SeriesDefinition
mkSeriesDefinition seriesDefinitionLabel seriesDefinitionSeriesType =
  SeriesDefinition
  { seriesDefinitionLabel
  , seriesDefinitionChannelName = Nothing
  , seriesDefinitionAliasId = Nothing
  , seriesDefinitionSeriesType
  }

-- ** SessionDTO
-- | SessionDTO
data SessionDTO = SessionDTO
    { sessionDTOSessionId :: !(Text) -- ^ /Required/ "sessionId"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SessionDTO
instance A.FromJSON SessionDTO where
  parseJSON = A.withObject "SessionDTO" $ \o ->
    SessionDTO
      <$> (o .:  "sessionId")

-- | ToJSON SessionDTO
instance A.ToJSON SessionDTO where
  toJSON SessionDTO {..} =
   _omitNulls
      [ "sessionId" .= sessionDTOSessionId
      ]


-- | Construct a value of type 'SessionDTO' (by applying it's required fields, if any)
mkSessionDTO
  :: Text -- ^ 'sessionDTOSessionId'
  -> SessionDTO
mkSessionDTO sessionDTOSessionId =
  SessionDTO
  { sessionDTOSessionId
  }

-- ** StateTransitions
-- | StateTransitions
data StateTransitions = StateTransitions
    { stateTransitionsRunning   :: !(Maybe DateTime) -- ^ "running"
    -- ^ "succeeded"
    , stateTransitionsSucceeded :: !(Maybe DateTime) -- ^ "succeeded"
    -- ^ "failed"
    , stateTransitionsFailed    :: !(Maybe DateTime) -- ^ "failed"
    -- ^ "aborted"
    , stateTransitionsAborted   :: !(Maybe DateTime) -- ^ "aborted"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StateTransitions
instance A.FromJSON StateTransitions where
  parseJSON = A.withObject "StateTransitions" $ \o ->
    StateTransitions
      <$> (o .:? "running")
      <*> (o .:? "succeeded")
      <*> (o .:? "failed")
      <*> (o .:? "aborted")

-- | ToJSON StateTransitions
instance A.ToJSON StateTransitions where
  toJSON StateTransitions {..} =
   _omitNulls
      [ "running" .= stateTransitionsRunning
      , "succeeded" .= stateTransitionsSucceeded
      , "failed" .= stateTransitionsFailed
      , "aborted" .= stateTransitionsAborted
      ]


-- | Construct a value of type 'StateTransitions' (by applying it's required fields, if any)
mkStateTransitions
  :: StateTransitions
mkStateTransitions =
  StateTransitions
  { stateTransitionsRunning = Nothing
  , stateTransitionsSucceeded = Nothing
  , stateTransitionsFailed = Nothing
  , stateTransitionsAborted = Nothing
  }

-- ** StorageUsage
-- | StorageUsage
data StorageUsage = StorageUsage
    { storageUsageUsage :: !(Integer) -- ^ /Required/ "usage"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StorageUsage
instance A.FromJSON StorageUsage where
  parseJSON = A.withObject "StorageUsage" $ \o ->
    StorageUsage
      <$> (o .:  "usage")

-- | ToJSON StorageUsage
instance A.ToJSON StorageUsage where
  toJSON StorageUsage {..} =
   _omitNulls
      [ "usage" .= storageUsageUsage
      ]


-- | Construct a value of type 'StorageUsage' (by applying it's required fields, if any)
mkStorageUsage
  :: Integer -- ^ 'storageUsageUsage'
  -> StorageUsage
mkStorageUsage storageUsageUsage =
  StorageUsage
  { storageUsageUsage
  }

-- ** SubscriptionCancelInfoDTO
-- | SubscriptionCancelInfoDTO
data SubscriptionCancelInfoDTO = SubscriptionCancelInfoDTO
    { subscriptionCancelInfoDTOReasons     :: !([Text]) -- ^ /Required/ "reasons"
    -- ^ "description"
    , subscriptionCancelInfoDTODescription :: !(Maybe Text) -- ^ "description"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubscriptionCancelInfoDTO
instance A.FromJSON SubscriptionCancelInfoDTO where
  parseJSON = A.withObject "SubscriptionCancelInfoDTO" $ \o ->
    SubscriptionCancelInfoDTO
      <$> (o .:  "reasons")
      <*> (o .:? "description")

-- | ToJSON SubscriptionCancelInfoDTO
instance A.ToJSON SubscriptionCancelInfoDTO where
  toJSON SubscriptionCancelInfoDTO {..} =
   _omitNulls
      [ "reasons" .= subscriptionCancelInfoDTOReasons
      , "description" .= subscriptionCancelInfoDTODescription
      ]


-- | Construct a value of type 'SubscriptionCancelInfoDTO' (by applying it's required fields, if any)
mkSubscriptionCancelInfoDTO
  :: [Text] -- ^ 'subscriptionCancelInfoDTOReasons'
  -> SubscriptionCancelInfoDTO
mkSubscriptionCancelInfoDTO subscriptionCancelInfoDTOReasons =
  SubscriptionCancelInfoDTO
  { subscriptionCancelInfoDTOReasons
  , subscriptionCancelInfoDTODescription = Nothing
  }

-- ** SystemMetric
-- | SystemMetric
data SystemMetric = SystemMetric
    { systemMetricSeries       :: !([Text]) -- ^ /Required/ "series"
    -- ^ /Required/ "name"
    , systemMetricName         :: !(Text) -- ^ /Required/ "name"
    -- ^ "min"
    , systemMetricMin          :: !(Maybe Double) -- ^ "min"
    -- ^ "max"
    , systemMetricMax          :: !(Maybe Double) -- ^ "max"
    -- ^ "unit"
    , systemMetricUnit         :: !(Maybe Text) -- ^ "unit"
    -- ^ /Required/ "description"
    , systemMetricDescription  :: !(Text) -- ^ /Required/ "description"
    -- ^ /Required/ "resourceType"
    , systemMetricResourceType :: !(SystemMetricResourceType) -- ^ /Required/ "resourceType"
    -- ^ /Required/ "experimentId"
    , systemMetricExperimentId :: !(Text) -- ^ /Required/ "experimentId"
    -- ^ /Required/ "id"
    , systemMetricId           :: !(Text) -- ^ /Required/ "id"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemMetric
instance A.FromJSON SystemMetric where
  parseJSON = A.withObject "SystemMetric" $ \o ->
    SystemMetric
      <$> (o .:  "series")
      <*> (o .:  "name")
      <*> (o .:? "min")
      <*> (o .:? "max")
      <*> (o .:? "unit")
      <*> (o .:  "description")
      <*> (o .:  "resourceType")
      <*> (o .:  "experimentId")
      <*> (o .:  "id")

-- | ToJSON SystemMetric
instance A.ToJSON SystemMetric where
  toJSON SystemMetric {..} =
   _omitNulls
      [ "series" .= systemMetricSeries
      , "name" .= systemMetricName
      , "min" .= systemMetricMin
      , "max" .= systemMetricMax
      , "unit" .= systemMetricUnit
      , "description" .= systemMetricDescription
      , "resourceType" .= systemMetricResourceType
      , "experimentId" .= systemMetricExperimentId
      , "id" .= systemMetricId
      ]


-- | Construct a value of type 'SystemMetric' (by applying it's required fields, if any)
mkSystemMetric
  :: [Text] -- ^ 'systemMetricSeries'
  -> Text -- ^ 'systemMetricName'
  -> Text -- ^ 'systemMetricDescription'
  -> SystemMetricResourceType -- ^ 'systemMetricResourceType'
  -> Text -- ^ 'systemMetricExperimentId'
  -> Text -- ^ 'systemMetricId'
  -> SystemMetric
mkSystemMetric systemMetricSeries systemMetricName systemMetricDescription systemMetricResourceType systemMetricExperimentId systemMetricId =
  SystemMetric
  { systemMetricSeries
  , systemMetricName
  , systemMetricMin = Nothing
  , systemMetricMax = Nothing
  , systemMetricUnit = Nothing
  , systemMetricDescription
  , systemMetricResourceType
  , systemMetricExperimentId
  , systemMetricId
  }

-- ** SystemMetricParams
-- | SystemMetricParams
data SystemMetricParams = SystemMetricParams
    { systemMetricParamsSeries       :: !([Text]) -- ^ /Required/ "series"
    -- ^ /Required/ "name"
    , systemMetricParamsName         :: !(Text) -- ^ /Required/ "name"
    -- ^ "min"
    , systemMetricParamsMin          :: !(Maybe Double) -- ^ "min"
    -- ^ "max"
    , systemMetricParamsMax          :: !(Maybe Double) -- ^ "max"
    -- ^ "unit"
    , systemMetricParamsUnit         :: !(Maybe Text) -- ^ "unit"
    -- ^ /Required/ "description"
    , systemMetricParamsDescription  :: !(Text) -- ^ /Required/ "description"
    -- ^ /Required/ "resourceType"
    , systemMetricParamsResourceType :: !(SystemMetricResourceType) -- ^ /Required/ "resourceType"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemMetricParams
instance A.FromJSON SystemMetricParams where
  parseJSON = A.withObject "SystemMetricParams" $ \o ->
    SystemMetricParams
      <$> (o .:  "series")
      <*> (o .:  "name")
      <*> (o .:? "min")
      <*> (o .:? "max")
      <*> (o .:? "unit")
      <*> (o .:  "description")
      <*> (o .:  "resourceType")

-- | ToJSON SystemMetricParams
instance A.ToJSON SystemMetricParams where
  toJSON SystemMetricParams {..} =
   _omitNulls
      [ "series" .= systemMetricParamsSeries
      , "name" .= systemMetricParamsName
      , "min" .= systemMetricParamsMin
      , "max" .= systemMetricParamsMax
      , "unit" .= systemMetricParamsUnit
      , "description" .= systemMetricParamsDescription
      , "resourceType" .= systemMetricParamsResourceType
      ]


-- | Construct a value of type 'SystemMetricParams' (by applying it's required fields, if any)
mkSystemMetricParams
  :: [Text] -- ^ 'systemMetricParamsSeries'
  -> Text -- ^ 'systemMetricParamsName'
  -> Text -- ^ 'systemMetricParamsDescription'
  -> SystemMetricResourceType -- ^ 'systemMetricParamsResourceType'
  -> SystemMetricParams
mkSystemMetricParams systemMetricParamsSeries systemMetricParamsName systemMetricParamsDescription systemMetricParamsResourceType =
  SystemMetricParams
  { systemMetricParamsSeries
  , systemMetricParamsName
  , systemMetricParamsMin = Nothing
  , systemMetricParamsMax = Nothing
  , systemMetricParamsUnit = Nothing
  , systemMetricParamsDescription
  , systemMetricParamsResourceType
  }

-- ** SystemMetricPoint
-- | SystemMetricPoint
data SystemMetricPoint = SystemMetricPoint
    { systemMetricPointTimestampMillis :: !(Integer) -- ^ /Required/ "timestampMillis"
    -- ^ /Required/ "x"
    , systemMetricPointX               :: !(Integer) -- ^ /Required/ "x"
    -- ^ /Required/ "y"
    , systemMetricPointY               :: !(Double) -- ^ /Required/ "y"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemMetricPoint
instance A.FromJSON SystemMetricPoint where
  parseJSON = A.withObject "SystemMetricPoint" $ \o ->
    SystemMetricPoint
      <$> (o .:  "timestampMillis")
      <*> (o .:  "x")
      <*> (o .:  "y")

-- | ToJSON SystemMetricPoint
instance A.ToJSON SystemMetricPoint where
  toJSON SystemMetricPoint {..} =
   _omitNulls
      [ "timestampMillis" .= systemMetricPointTimestampMillis
      , "x" .= systemMetricPointX
      , "y" .= systemMetricPointY
      ]


-- | Construct a value of type 'SystemMetricPoint' (by applying it's required fields, if any)
mkSystemMetricPoint
  :: Integer -- ^ 'systemMetricPointTimestampMillis'
  -> Integer -- ^ 'systemMetricPointX'
  -> Double -- ^ 'systemMetricPointY'
  -> SystemMetricPoint
mkSystemMetricPoint systemMetricPointTimestampMillis systemMetricPointX systemMetricPointY =
  SystemMetricPoint
  { systemMetricPointTimestampMillis
  , systemMetricPointX
  , systemMetricPointY
  }

-- ** SystemMetricValues
-- | SystemMetricValues
data SystemMetricValues = SystemMetricValues
    { systemMetricValuesMetricId   :: !(Text) -- ^ /Required/ "metricId"
    -- ^ /Required/ "seriesName"
    , systemMetricValuesSeriesName :: !(Text) -- ^ /Required/ "seriesName"
    -- ^ "level"
    , systemMetricValuesLevel      :: !(Maybe Int) -- ^ "level"
    -- ^ /Required/ "values"
    , systemMetricValuesValues     :: !([SystemMetricPoint]) -- ^ /Required/ "values"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemMetricValues
instance A.FromJSON SystemMetricValues where
  parseJSON = A.withObject "SystemMetricValues" $ \o ->
    SystemMetricValues
      <$> (o .:  "metricId")
      <*> (o .:  "seriesName")
      <*> (o .:? "level")
      <*> (o .:  "values")

-- | ToJSON SystemMetricValues
instance A.ToJSON SystemMetricValues where
  toJSON SystemMetricValues {..} =
   _omitNulls
      [ "metricId" .= systemMetricValuesMetricId
      , "seriesName" .= systemMetricValuesSeriesName
      , "level" .= systemMetricValuesLevel
      , "values" .= systemMetricValuesValues
      ]


-- | Construct a value of type 'SystemMetricValues' (by applying it's required fields, if any)
mkSystemMetricValues
  :: Text -- ^ 'systemMetricValuesMetricId'
  -> Text -- ^ 'systemMetricValuesSeriesName'
  -> [SystemMetricPoint] -- ^ 'systemMetricValuesValues'
  -> SystemMetricValues
mkSystemMetricValues systemMetricValuesMetricId systemMetricValuesSeriesName systemMetricValuesValues =
  SystemMetricValues
  { systemMetricValuesMetricId
  , systemMetricValuesSeriesName
  , systemMetricValuesLevel = Nothing
  , systemMetricValuesValues
  }

-- ** UUID
-- | UUID
data UUID = UUID
    { uUIDMostSigBits  :: !(Integer) -- ^ /Required/ "mostSigBits"
    -- ^ /Required/ "leastSigBits"
    , uUIDLeastSigBits :: !(Integer) -- ^ /Required/ "leastSigBits"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UUID
instance A.FromJSON UUID where
  parseJSON = A.withObject "UUID" $ \o ->
    UUID
      <$> (o .:  "mostSigBits")
      <*> (o .:  "leastSigBits")

-- | ToJSON UUID
instance A.ToJSON UUID where
  toJSON UUID {..} =
   _omitNulls
      [ "mostSigBits" .= uUIDMostSigBits
      , "leastSigBits" .= uUIDLeastSigBits
      ]


-- | Construct a value of type 'UUID' (by applying it's required fields, if any)
mkUUID
  :: Integer -- ^ 'uUIDMostSigBits'
  -> Integer -- ^ 'uUIDLeastSigBits'
  -> UUID
mkUUID uUIDMostSigBits uUIDLeastSigBits =
  UUID
  { uUIDMostSigBits
  , uUIDLeastSigBits
  }

-- ** UpdateTagsParams
-- | UpdateTagsParams
data UpdateTagsParams = UpdateTagsParams
    { updateTagsParamsExperimentIds :: !([Text]) -- ^ /Required/ "experimentIds"
    -- ^ /Required/ "tagsToAdd"
    , updateTagsParamsTagsToAdd     :: !([Text]) -- ^ /Required/ "tagsToAdd"
    -- ^ /Required/ "tagsToDelete"
    , updateTagsParamsTagsToDelete  :: !([Text]) -- ^ /Required/ "tagsToDelete"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateTagsParams
instance A.FromJSON UpdateTagsParams where
  parseJSON = A.withObject "UpdateTagsParams" $ \o ->
    UpdateTagsParams
      <$> (o .:  "experimentIds")
      <*> (o .:  "tagsToAdd")
      <*> (o .:  "tagsToDelete")

-- | ToJSON UpdateTagsParams
instance A.ToJSON UpdateTagsParams where
  toJSON UpdateTagsParams {..} =
   _omitNulls
      [ "experimentIds" .= updateTagsParamsExperimentIds
      , "tagsToAdd" .= updateTagsParamsTagsToAdd
      , "tagsToDelete" .= updateTagsParamsTagsToDelete
      ]


-- | Construct a value of type 'UpdateTagsParams' (by applying it's required fields, if any)
mkUpdateTagsParams
  :: [Text] -- ^ 'updateTagsParamsExperimentIds'
  -> [Text] -- ^ 'updateTagsParamsTagsToAdd'
  -> [Text] -- ^ 'updateTagsParamsTagsToDelete'
  -> UpdateTagsParams
mkUpdateTagsParams updateTagsParamsExperimentIds updateTagsParamsTagsToAdd updateTagsParamsTagsToDelete =
  UpdateTagsParams
  { updateTagsParamsExperimentIds
  , updateTagsParamsTagsToAdd
  , updateTagsParamsTagsToDelete
  }

-- ** UserListDTO
-- | UserListDTO
data UserListDTO = UserListDTO
    { userListDTOEntries           :: !([UserListItemDTO]) -- ^ /Required/ "entries"
    -- ^ /Required/ "matchingItemCount"
    , userListDTOMatchingItemCount :: !(Int) -- ^ /Required/ "matchingItemCount"
    -- ^ /Required/ "totalItemCount"
    , userListDTOTotalItemCount    :: !(Int) -- ^ /Required/ "totalItemCount"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserListDTO
instance A.FromJSON UserListDTO where
  parseJSON = A.withObject "UserListDTO" $ \o ->
    UserListDTO
      <$> (o .:  "entries")
      <*> (o .:  "matchingItemCount")
      <*> (o .:  "totalItemCount")

-- | ToJSON UserListDTO
instance A.ToJSON UserListDTO where
  toJSON UserListDTO {..} =
   _omitNulls
      [ "entries" .= userListDTOEntries
      , "matchingItemCount" .= userListDTOMatchingItemCount
      , "totalItemCount" .= userListDTOTotalItemCount
      ]


-- | Construct a value of type 'UserListDTO' (by applying it's required fields, if any)
mkUserListDTO
  :: [UserListItemDTO] -- ^ 'userListDTOEntries'
  -> Int -- ^ 'userListDTOMatchingItemCount'
  -> Int -- ^ 'userListDTOTotalItemCount'
  -> UserListDTO
mkUserListDTO userListDTOEntries userListDTOMatchingItemCount userListDTOTotalItemCount =
  UserListDTO
  { userListDTOEntries
  , userListDTOMatchingItemCount
  , userListDTOTotalItemCount
  }

-- ** UserListItemDTO
-- | UserListItemDTO
data UserListItemDTO = UserListItemDTO
    { userListItemDTOAvatarSource :: !(AvatarSourceEnum) -- ^ /Required/ "avatarSource"
    -- ^ /Required/ "lastName"
    , userListItemDTOLastName     :: !(Text) -- ^ /Required/ "lastName"
    -- ^ /Required/ "firstName"
    , userListItemDTOFirstName    :: !(Text) -- ^ /Required/ "firstName"
    -- ^ /Required/ "username"
    , userListItemDTOUsername     :: !(Text) -- ^ /Required/ "username"
    -- ^ /Required/ "avatarUrl"
    , userListItemDTOAvatarUrl    :: !(Text) -- ^ /Required/ "avatarUrl"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserListItemDTO
instance A.FromJSON UserListItemDTO where
  parseJSON = A.withObject "UserListItemDTO" $ \o ->
    UserListItemDTO
      <$> (o .:  "avatarSource")
      <*> (o .:  "lastName")
      <*> (o .:  "firstName")
      <*> (o .:  "username")
      <*> (o .:  "avatarUrl")

-- | ToJSON UserListItemDTO
instance A.ToJSON UserListItemDTO where
  toJSON UserListItemDTO {..} =
   _omitNulls
      [ "avatarSource" .= userListItemDTOAvatarSource
      , "lastName" .= userListItemDTOLastName
      , "firstName" .= userListItemDTOFirstName
      , "username" .= userListItemDTOUsername
      , "avatarUrl" .= userListItemDTOAvatarUrl
      ]


-- | Construct a value of type 'UserListItemDTO' (by applying it's required fields, if any)
mkUserListItemDTO
  :: AvatarSourceEnum -- ^ 'userListItemDTOAvatarSource'
  -> Text -- ^ 'userListItemDTOLastName'
  -> Text -- ^ 'userListItemDTOFirstName'
  -> Text -- ^ 'userListItemDTOUsername'
  -> Text -- ^ 'userListItemDTOAvatarUrl'
  -> UserListItemDTO
mkUserListItemDTO userListItemDTOAvatarSource userListItemDTOLastName userListItemDTOFirstName userListItemDTOUsername userListItemDTOAvatarUrl =
  UserListItemDTO
  { userListItemDTOAvatarSource
  , userListItemDTOLastName
  , userListItemDTOFirstName
  , userListItemDTOUsername
  , userListItemDTOAvatarUrl
  }

-- ** UserPricingStatusDTO
-- | UserPricingStatusDTO
data UserPricingStatusDTO = UserPricingStatusDTO
    { userPricingStatusDTOCanCreateTeamFree :: !(Bool) -- ^ /Required/ "canCreateTeamFree"
    -- ^ "anyTeamFree"
    , userPricingStatusDTOAnyTeamFree       :: !(Maybe OrganizationWithRoleDTO) -- ^ "anyTeamFree"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserPricingStatusDTO
instance A.FromJSON UserPricingStatusDTO where
  parseJSON = A.withObject "UserPricingStatusDTO" $ \o ->
    UserPricingStatusDTO
      <$> (o .:  "canCreateTeamFree")
      <*> (o .:? "anyTeamFree")

-- | ToJSON UserPricingStatusDTO
instance A.ToJSON UserPricingStatusDTO where
  toJSON UserPricingStatusDTO {..} =
   _omitNulls
      [ "canCreateTeamFree" .= userPricingStatusDTOCanCreateTeamFree
      , "anyTeamFree" .= userPricingStatusDTOAnyTeamFree
      ]


-- | Construct a value of type 'UserPricingStatusDTO' (by applying it's required fields, if any)
mkUserPricingStatusDTO
  :: Bool -- ^ 'userPricingStatusDTOCanCreateTeamFree'
  -> UserPricingStatusDTO
mkUserPricingStatusDTO userPricingStatusDTOCanCreateTeamFree =
  UserPricingStatusDTO
  { userPricingStatusDTOCanCreateTeamFree
  , userPricingStatusDTOAnyTeamFree = Nothing
  }

-- ** UserProfileDTO
-- | UserProfileDTO
data UserProfileDTO = UserProfileDTO
    { userProfileDTOUsernameHash          :: !(Text) -- ^ /Required/ "usernameHash"
    -- ^ /Required/ "email"
    , userProfileDTOEmail                 :: !(Text) -- ^ /Required/ "email"
    -- ^ /Required/ "hasLoggedToCli"
    , userProfileDTOHasLoggedToCli        :: !(Bool) -- ^ /Required/ "hasLoggedToCli"
    -- ^ /Required/ "avatarSource"
    , userProfileDTOAvatarSource          :: !(AvatarSourceEnum) -- ^ /Required/ "avatarSource"
    -- ^ /Required/ "firstName"
    , userProfileDTOFirstName             :: !(Text) -- ^ /Required/ "firstName"
    -- ^ /Required/ "shortInfo"
    , userProfileDTOShortInfo             :: !(Text) -- ^ /Required/ "shortInfo"
    -- ^ /Required/ "created"
    , userProfileDTOCreated               :: !(DateTime) -- ^ /Required/ "created"
    -- ^ /Required/ "biography"
    , userProfileDTOBiography             :: !(Text) -- ^ /Required/ "biography"
    -- ^ /Required/ "hasCreatedExperiments"
    , userProfileDTOHasCreatedExperiments :: !(Bool) -- ^ /Required/ "hasCreatedExperiments"
    -- ^ /Required/ "username"
    , userProfileDTOUsername              :: !(Text) -- ^ /Required/ "username"
    -- ^ /Required/ "avatarUrl"
    , userProfileDTOAvatarUrl             :: !(Text) -- ^ /Required/ "avatarUrl"
    -- ^ /Required/ "lastName"
    , userProfileDTOLastName              :: !(Text) -- ^ /Required/ "lastName"
    -- ^ /Required/ "links"
    , userProfileDTOLinks                 :: !(UserProfileLinksDTO) -- ^ /Required/ "links"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserProfileDTO
instance A.FromJSON UserProfileDTO where
  parseJSON = A.withObject "UserProfileDTO" $ \o ->
    UserProfileDTO
      <$> (o .:  "usernameHash")
      <*> (o .:  "email")
      <*> (o .:  "hasLoggedToCli")
      <*> (o .:  "avatarSource")
      <*> (o .:  "firstName")
      <*> (o .:  "shortInfo")
      <*> (o .:  "created")
      <*> (o .:  "biography")
      <*> (o .:  "hasCreatedExperiments")
      <*> (o .:  "username")
      <*> (o .:  "avatarUrl")
      <*> (o .:  "lastName")
      <*> (o .:  "links")

-- | ToJSON UserProfileDTO
instance A.ToJSON UserProfileDTO where
  toJSON UserProfileDTO {..} =
   _omitNulls
      [ "usernameHash" .= userProfileDTOUsernameHash
      , "email" .= userProfileDTOEmail
      , "hasLoggedToCli" .= userProfileDTOHasLoggedToCli
      , "avatarSource" .= userProfileDTOAvatarSource
      , "firstName" .= userProfileDTOFirstName
      , "shortInfo" .= userProfileDTOShortInfo
      , "created" .= userProfileDTOCreated
      , "biography" .= userProfileDTOBiography
      , "hasCreatedExperiments" .= userProfileDTOHasCreatedExperiments
      , "username" .= userProfileDTOUsername
      , "avatarUrl" .= userProfileDTOAvatarUrl
      , "lastName" .= userProfileDTOLastName
      , "links" .= userProfileDTOLinks
      ]


-- | Construct a value of type 'UserProfileDTO' (by applying it's required fields, if any)
mkUserProfileDTO
  :: Text -- ^ 'userProfileDTOUsernameHash'
  -> Text -- ^ 'userProfileDTOEmail'
  -> Bool -- ^ 'userProfileDTOHasLoggedToCli'
  -> AvatarSourceEnum -- ^ 'userProfileDTOAvatarSource'
  -> Text -- ^ 'userProfileDTOFirstName'
  -> Text -- ^ 'userProfileDTOShortInfo'
  -> DateTime -- ^ 'userProfileDTOCreated'
  -> Text -- ^ 'userProfileDTOBiography'
  -> Bool -- ^ 'userProfileDTOHasCreatedExperiments'
  -> Text -- ^ 'userProfileDTOUsername'
  -> Text -- ^ 'userProfileDTOAvatarUrl'
  -> Text -- ^ 'userProfileDTOLastName'
  -> UserProfileLinksDTO -- ^ 'userProfileDTOLinks'
  -> UserProfileDTO
mkUserProfileDTO userProfileDTOUsernameHash userProfileDTOEmail userProfileDTOHasLoggedToCli userProfileDTOAvatarSource userProfileDTOFirstName userProfileDTOShortInfo userProfileDTOCreated userProfileDTOBiography userProfileDTOHasCreatedExperiments userProfileDTOUsername userProfileDTOAvatarUrl userProfileDTOLastName userProfileDTOLinks =
  UserProfileDTO
  { userProfileDTOUsernameHash
  , userProfileDTOEmail
  , userProfileDTOHasLoggedToCli
  , userProfileDTOAvatarSource
  , userProfileDTOFirstName
  , userProfileDTOShortInfo
  , userProfileDTOCreated
  , userProfileDTOBiography
  , userProfileDTOHasCreatedExperiments
  , userProfileDTOUsername
  , userProfileDTOAvatarUrl
  , userProfileDTOLastName
  , userProfileDTOLinks
  }

-- ** UserProfileLinkDTO
-- | UserProfileLinkDTO
data UserProfileLinkDTO = UserProfileLinkDTO
    { userProfileLinkDTOLinkType :: !(LinkTypeDTO) -- ^ /Required/ "linkType"
    -- ^ /Required/ "url"
    , userProfileLinkDTOUrl      :: !(Text) -- ^ /Required/ "url"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserProfileLinkDTO
instance A.FromJSON UserProfileLinkDTO where
  parseJSON = A.withObject "UserProfileLinkDTO" $ \o ->
    UserProfileLinkDTO
      <$> (o .:  "linkType")
      <*> (o .:  "url")

-- | ToJSON UserProfileLinkDTO
instance A.ToJSON UserProfileLinkDTO where
  toJSON UserProfileLinkDTO {..} =
   _omitNulls
      [ "linkType" .= userProfileLinkDTOLinkType
      , "url" .= userProfileLinkDTOUrl
      ]


-- | Construct a value of type 'UserProfileLinkDTO' (by applying it's required fields, if any)
mkUserProfileLinkDTO
  :: LinkTypeDTO -- ^ 'userProfileLinkDTOLinkType'
  -> Text -- ^ 'userProfileLinkDTOUrl'
  -> UserProfileLinkDTO
mkUserProfileLinkDTO userProfileLinkDTOLinkType userProfileLinkDTOUrl =
  UserProfileLinkDTO
  { userProfileLinkDTOLinkType
  , userProfileLinkDTOUrl
  }

-- ** UserProfileLinksDTO
-- | UserProfileLinksDTO
data UserProfileLinksDTO = UserProfileLinksDTO
    { userProfileLinksDTOGithub   :: !(Maybe Text) -- ^ "github"
    -- ^ "linkedin"
    , userProfileLinksDTOLinkedin :: !(Maybe Text) -- ^ "linkedin"
    -- ^ /Required/ "others"
    , userProfileLinksDTOOthers   :: !([Text]) -- ^ /Required/ "others"
    -- ^ "kaggle"
    , userProfileLinksDTOKaggle   :: !(Maybe Text) -- ^ "kaggle"
    -- ^ "twitter"
    , userProfileLinksDTOTwitter  :: !(Maybe Text) -- ^ "twitter"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserProfileLinksDTO
instance A.FromJSON UserProfileLinksDTO where
  parseJSON = A.withObject "UserProfileLinksDTO" $ \o ->
    UserProfileLinksDTO
      <$> (o .:? "github")
      <*> (o .:? "linkedin")
      <*> (o .:  "others")
      <*> (o .:? "kaggle")
      <*> (o .:? "twitter")

-- | ToJSON UserProfileLinksDTO
instance A.ToJSON UserProfileLinksDTO where
  toJSON UserProfileLinksDTO {..} =
   _omitNulls
      [ "github" .= userProfileLinksDTOGithub
      , "linkedin" .= userProfileLinksDTOLinkedin
      , "others" .= userProfileLinksDTOOthers
      , "kaggle" .= userProfileLinksDTOKaggle
      , "twitter" .= userProfileLinksDTOTwitter
      ]


-- | Construct a value of type 'UserProfileLinksDTO' (by applying it's required fields, if any)
mkUserProfileLinksDTO
  :: [Text] -- ^ 'userProfileLinksDTOOthers'
  -> UserProfileLinksDTO
mkUserProfileLinksDTO userProfileLinksDTOOthers =
  UserProfileLinksDTO
  { userProfileLinksDTOGithub = Nothing
  , userProfileLinksDTOLinkedin = Nothing
  , userProfileLinksDTOOthers
  , userProfileLinksDTOKaggle = Nothing
  , userProfileLinksDTOTwitter = Nothing
  }

-- ** UserProfileUpdateDTO
-- | UserProfileUpdateDTO
data UserProfileUpdateDTO = UserProfileUpdateDTO
    { userProfileUpdateDTOBiography      :: !(Maybe Text) -- ^ "biography"
    -- ^ "hasLoggedToCli"
    , userProfileUpdateDTOHasLoggedToCli :: !(Maybe Bool) -- ^ "hasLoggedToCli"
    -- ^ "lastName"
    , userProfileUpdateDTOLastName       :: !(Maybe Text) -- ^ "lastName"
    -- ^ "firstName"
    , userProfileUpdateDTOFirstName      :: !(Maybe Text) -- ^ "firstName"
    -- ^ "shortInfo"
    , userProfileUpdateDTOShortInfo      :: !(Maybe Text) -- ^ "shortInfo"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserProfileUpdateDTO
instance A.FromJSON UserProfileUpdateDTO where
  parseJSON = A.withObject "UserProfileUpdateDTO" $ \o ->
    UserProfileUpdateDTO
      <$> (o .:? "biography")
      <*> (o .:? "hasLoggedToCli")
      <*> (o .:? "lastName")
      <*> (o .:? "firstName")
      <*> (o .:? "shortInfo")

-- | ToJSON UserProfileUpdateDTO
instance A.ToJSON UserProfileUpdateDTO where
  toJSON UserProfileUpdateDTO {..} =
   _omitNulls
      [ "biography" .= userProfileUpdateDTOBiography
      , "hasLoggedToCli" .= userProfileUpdateDTOHasLoggedToCli
      , "lastName" .= userProfileUpdateDTOLastName
      , "firstName" .= userProfileUpdateDTOFirstName
      , "shortInfo" .= userProfileUpdateDTOShortInfo
      ]


-- | Construct a value of type 'UserProfileUpdateDTO' (by applying it's required fields, if any)
mkUserProfileUpdateDTO
  :: UserProfileUpdateDTO
mkUserProfileUpdateDTO =
  UserProfileUpdateDTO
  { userProfileUpdateDTOBiography = Nothing
  , userProfileUpdateDTOHasLoggedToCli = Nothing
  , userProfileUpdateDTOLastName = Nothing
  , userProfileUpdateDTOFirstName = Nothing
  , userProfileUpdateDTOShortInfo = Nothing
  }

-- ** UsernameValidationStatusDTO
-- | UsernameValidationStatusDTO
data UsernameValidationStatusDTO = UsernameValidationStatusDTO
    { usernameValidationStatusDTOStatus :: !(UsernameValidationStatusEnumDTO) -- ^ /Required/ "status"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UsernameValidationStatusDTO
instance A.FromJSON UsernameValidationStatusDTO where
  parseJSON = A.withObject "UsernameValidationStatusDTO" $ \o ->
    UsernameValidationStatusDTO
      <$> (o .:  "status")

-- | ToJSON UsernameValidationStatusDTO
instance A.ToJSON UsernameValidationStatusDTO where
  toJSON UsernameValidationStatusDTO {..} =
   _omitNulls
      [ "status" .= usernameValidationStatusDTOStatus
      ]


-- | Construct a value of type 'UsernameValidationStatusDTO' (by applying it's required fields, if any)
mkUsernameValidationStatusDTO
  :: UsernameValidationStatusEnumDTO -- ^ 'usernameValidationStatusDTOStatus'
  -> UsernameValidationStatusDTO
mkUsernameValidationStatusDTO usernameValidationStatusDTOStatus =
  UsernameValidationStatusDTO
  { usernameValidationStatusDTOStatus
  }

-- ** Version
-- | Version
data Version = Version
    { versionVersion :: !(Text) -- ^ /Required/ "version"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Version
instance A.FromJSON Version where
  parseJSON = A.withObject "Version" $ \o ->
    Version
      <$> (o .:  "version")

-- | ToJSON Version
instance A.ToJSON Version where
  toJSON Version {..} =
   _omitNulls
      [ "version" .= versionVersion
      ]


-- | Construct a value of type 'Version' (by applying it's required fields, if any)
mkVersion
  :: Text -- ^ 'versionVersion'
  -> Version
mkVersion versionVersion =
  Version
  { versionVersion
  }

-- ** WorkspaceConfig
-- | WorkspaceConfig
data WorkspaceConfig = WorkspaceConfig
    { workspaceConfigRealm   :: !(Text) -- ^ /Required/ "realm"
    -- ^ /Required/ "idpHint"
    , workspaceConfigIdpHint :: !(Text) -- ^ /Required/ "idpHint"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceConfig
instance A.FromJSON WorkspaceConfig where
  parseJSON = A.withObject "WorkspaceConfig" $ \o ->
    WorkspaceConfig
      <$> (o .:  "realm")
      <*> (o .:  "idpHint")

-- | ToJSON WorkspaceConfig
instance A.ToJSON WorkspaceConfig where
  toJSON WorkspaceConfig {..} =
   _omitNulls
      [ "realm" .= workspaceConfigRealm
      , "idpHint" .= workspaceConfigIdpHint
      ]


-- | Construct a value of type 'WorkspaceConfig' (by applying it's required fields, if any)
mkWorkspaceConfig
  :: Text -- ^ 'workspaceConfigRealm'
  -> Text -- ^ 'workspaceConfigIdpHint'
  -> WorkspaceConfig
mkWorkspaceConfig workspaceConfigRealm workspaceConfigIdpHint =
  WorkspaceConfig
  { workspaceConfigRealm
  , workspaceConfigIdpHint
  }

-- ** Y
-- | Y
data Y = Y
    { yNumericValue    :: !(Maybe Double) -- ^ "numericValue"
    -- ^ "textValue"
    , yTextValue       :: !(Maybe Text) -- ^ "textValue"
    -- ^ "imageValue"
    , yImageValue      :: !(Maybe OutputImageDTO) -- ^ "imageValue"
    -- ^ "inputImageValue"
    , yInputImageValue :: !(Maybe InputImageDTO) -- ^ "inputImageValue"
    }
    deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Y
instance A.FromJSON Y where
  parseJSON = A.withObject "Y" $ \o ->
    Y
      <$> (o .:? "numericValue")
      <*> (o .:? "textValue")
      <*> (o .:? "imageValue")
      <*> (o .:? "inputImageValue")

-- | ToJSON Y
instance A.ToJSON Y where
  toJSON Y {..} =
   _omitNulls
      [ "numericValue" .= yNumericValue
      , "textValue" .= yTextValue
      , "imageValue" .= yImageValue
      , "inputImageValue" .= yInputImageValue
      ]


-- | Construct a value of type 'Y' (by applying it's required fields, if any)
mkY
  :: Y
mkY =
  Y
  { yNumericValue = Nothing
  , yTextValue = Nothing
  , yImageValue = Nothing
  , yInputImageValue = Nothing
  }


-- * Enums


-- ** AchievementTypeDTO

-- | Enum of 'Text'
data AchievementTypeDTO = AchievementTypeDTO'ArtifactSent
    | AchievementTypeDTO'ExperimentCreated
    | AchievementTypeDTO'ImageSent
    | AchievementTypeDTO'ParameterSet
    | AchievementTypeDTO'SourceUploaded
    | AchievementTypeDTO'TagSet
    | AchievementTypeDTO'TextSent
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AchievementTypeDTO where toJSON = A.toJSON . fromAchievementTypeDTO
instance A.FromJSON AchievementTypeDTO where parseJSON o = P.either P.fail (pure . P.id) . toAchievementTypeDTO =<< A.parseJSON o
instance WH.ToHttpApiData AchievementTypeDTO where toQueryParam = WH.toQueryParam . fromAchievementTypeDTO
instance WH.FromHttpApiData AchievementTypeDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAchievementTypeDTO
instance MimeRender MimeMultipartFormData AchievementTypeDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AchievementTypeDTO' enum
fromAchievementTypeDTO :: AchievementTypeDTO -> Text
fromAchievementTypeDTO = \case
  AchievementTypeDTO'ArtifactSent      -> "artifactSent"
  AchievementTypeDTO'ExperimentCreated -> "experimentCreated"
  AchievementTypeDTO'ImageSent         -> "imageSent"
  AchievementTypeDTO'ParameterSet      -> "parameterSet"
  AchievementTypeDTO'SourceUploaded    -> "sourceUploaded"
  AchievementTypeDTO'TagSet            -> "tagSet"
  AchievementTypeDTO'TextSent          -> "textSent"

-- | parse 'AchievementTypeDTO' enum
toAchievementTypeDTO :: Text -> P.Either String AchievementTypeDTO
toAchievementTypeDTO = \case
  "artifactSent" -> P.Right AchievementTypeDTO'ArtifactSent
  "experimentCreated" -> P.Right AchievementTypeDTO'ExperimentCreated
  "imageSent" -> P.Right AchievementTypeDTO'ImageSent
  "parameterSet" -> P.Right AchievementTypeDTO'ParameterSet
  "sourceUploaded" -> P.Right AchievementTypeDTO'SourceUploaded
  "tagSet" -> P.Right AchievementTypeDTO'TagSet
  "textSent" -> P.Right AchievementTypeDTO'TextSent
  s -> P.Left $ "toAchievementTypeDTO: enum parse failure: " P.++ P.show s


-- ** ApiErrorTypeDTO

-- | Enum of 'Text'
data ApiErrorTypeDTO = ApiErrorTypeDTO'PROJECTS_REACHED
    | ApiErrorTypeDTO'STORAGE_IN_PROJECT_REACHED
    | ApiErrorTypeDTO'MEMBERS_IN_ORGANIZATION_REACHED
    | ApiErrorTypeDTO'VALUES_IN_CHANNEL_REACHED
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ApiErrorTypeDTO where toJSON = A.toJSON . fromApiErrorTypeDTO
instance A.FromJSON ApiErrorTypeDTO where parseJSON o = P.either P.fail (pure . P.id) . toApiErrorTypeDTO =<< A.parseJSON o
instance WH.ToHttpApiData ApiErrorTypeDTO where toQueryParam = WH.toQueryParam . fromApiErrorTypeDTO
instance WH.FromHttpApiData ApiErrorTypeDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toApiErrorTypeDTO
instance MimeRender MimeMultipartFormData ApiErrorTypeDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ApiErrorTypeDTO' enum
fromApiErrorTypeDTO :: ApiErrorTypeDTO -> Text
fromApiErrorTypeDTO = \case
  ApiErrorTypeDTO'PROJECTS_REACHED -> "LIMIT_OF_PROJECTS_REACHED"
  ApiErrorTypeDTO'STORAGE_IN_PROJECT_REACHED -> "LIMIT_OF_STORAGE_IN_PROJECT_REACHED"
  ApiErrorTypeDTO'MEMBERS_IN_ORGANIZATION_REACHED -> "LIMIT_OF_MEMBERS_IN_ORGANIZATION_REACHED"
  ApiErrorTypeDTO'VALUES_IN_CHANNEL_REACHED -> "LIMIT_OF_VALUES_IN_CHANNEL_REACHED"

-- | parse 'ApiErrorTypeDTO' enum
toApiErrorTypeDTO :: Text -> P.Either String ApiErrorTypeDTO
toApiErrorTypeDTO = \case
  "LIMIT_OF_PROJECTS_REACHED" -> P.Right ApiErrorTypeDTO'PROJECTS_REACHED
  "LIMIT_OF_STORAGE_IN_PROJECT_REACHED" -> P.Right ApiErrorTypeDTO'STORAGE_IN_PROJECT_REACHED
  "LIMIT_OF_MEMBERS_IN_ORGANIZATION_REACHED" -> P.Right ApiErrorTypeDTO'MEMBERS_IN_ORGANIZATION_REACHED
  "LIMIT_OF_VALUES_IN_CHANNEL_REACHED" -> P.Right ApiErrorTypeDTO'VALUES_IN_CHANNEL_REACHED
  s -> P.Left $ "toApiErrorTypeDTO: enum parse failure: " P.++ P.show s


-- ** AvatarSourceEnum

-- | Enum of 'Text'
data AvatarSourceEnum = AvatarSourceEnum'Default
    | AvatarSourceEnum'ThirdParty
    | AvatarSourceEnum'User
    | AvatarSourceEnum'Inherited
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AvatarSourceEnum where toJSON = A.toJSON . fromAvatarSourceEnum
instance A.FromJSON AvatarSourceEnum where parseJSON o = P.either P.fail (pure . P.id) . toAvatarSourceEnum =<< A.parseJSON o
instance WH.ToHttpApiData AvatarSourceEnum where toQueryParam = WH.toQueryParam . fromAvatarSourceEnum
instance WH.FromHttpApiData AvatarSourceEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAvatarSourceEnum
instance MimeRender MimeMultipartFormData AvatarSourceEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AvatarSourceEnum' enum
fromAvatarSourceEnum :: AvatarSourceEnum -> Text
fromAvatarSourceEnum = \case
  AvatarSourceEnum'Default    -> "default"
  AvatarSourceEnum'ThirdParty -> "thirdParty"
  AvatarSourceEnum'User       -> "user"
  AvatarSourceEnum'Inherited  -> "inherited"

-- | parse 'AvatarSourceEnum' enum
toAvatarSourceEnum :: Text -> P.Either String AvatarSourceEnum
toAvatarSourceEnum = \case
  "default" -> P.Right AvatarSourceEnum'Default
  "thirdParty" -> P.Right AvatarSourceEnum'ThirdParty
  "user" -> P.Right AvatarSourceEnum'User
  "inherited" -> P.Right AvatarSourceEnum'Inherited
  s -> P.Left $ "toAvatarSourceEnum: enum parse failure: " P.++ P.show s


-- ** ChannelType

-- | Enum of 'Text'
data ChannelType = ChannelType'Numeric
    | ChannelType'Text
    | ChannelType'Image
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ChannelType where toJSON = A.toJSON . fromChannelType
instance A.FromJSON ChannelType where parseJSON o = P.either P.fail (pure . P.id) . toChannelType =<< A.parseJSON o
instance WH.ToHttpApiData ChannelType where toQueryParam = WH.toQueryParam . fromChannelType
instance WH.FromHttpApiData ChannelType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toChannelType
instance MimeRender MimeMultipartFormData ChannelType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ChannelType' enum
fromChannelType :: ChannelType -> Text
fromChannelType = \case
  ChannelType'Numeric -> "numeric"
  ChannelType'Text    -> "text"
  ChannelType'Image   -> "image"

-- | parse 'ChannelType' enum
toChannelType :: Text -> P.Either String ChannelType
toChannelType = \case
  "numeric" -> P.Right ChannelType'Numeric
  "text"    -> P.Right ChannelType'Text
  "image"   -> P.Right ChannelType'Image
  s         -> P.Left $ "toChannelType: enum parse failure: " P.++ P.show s


-- ** ChannelTypeEnum

-- | Enum of 'Text'
data ChannelTypeEnum = ChannelTypeEnum'Numeric
    | ChannelTypeEnum'Text
    | ChannelTypeEnum'Image
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ChannelTypeEnum where toJSON = A.toJSON . fromChannelTypeEnum
instance A.FromJSON ChannelTypeEnum where parseJSON o = P.either P.fail (pure . P.id) . toChannelTypeEnum =<< A.parseJSON o
instance WH.ToHttpApiData ChannelTypeEnum where toQueryParam = WH.toQueryParam . fromChannelTypeEnum
instance WH.FromHttpApiData ChannelTypeEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toChannelTypeEnum
instance MimeRender MimeMultipartFormData ChannelTypeEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ChannelTypeEnum' enum
fromChannelTypeEnum :: ChannelTypeEnum -> Text
fromChannelTypeEnum = \case
  ChannelTypeEnum'Numeric -> "numeric"
  ChannelTypeEnum'Text    -> "text"
  ChannelTypeEnum'Image   -> "image"

-- | parse 'ChannelTypeEnum' enum
toChannelTypeEnum :: Text -> P.Either String ChannelTypeEnum
toChannelTypeEnum = \case
  "numeric" -> P.Right ChannelTypeEnum'Numeric
  "text"    -> P.Right ChannelTypeEnum'Text
  "image"   -> P.Right ChannelTypeEnum'Image
  s         -> P.Left $ "toChannelTypeEnum: enum parse failure: " P.++ P.show s


-- ** ExperimentState

-- | Enum of 'Text'
data ExperimentState = ExperimentState'Running
    | ExperimentState'Succeeded
    | ExperimentState'Failed
    | ExperimentState'Aborted
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ExperimentState where toJSON = A.toJSON . fromExperimentState
instance A.FromJSON ExperimentState where parseJSON o = P.either P.fail (pure . P.id) . toExperimentState =<< A.parseJSON o
instance WH.ToHttpApiData ExperimentState where toQueryParam = WH.toQueryParam . fromExperimentState
instance WH.FromHttpApiData ExperimentState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toExperimentState
instance MimeRender MimeMultipartFormData ExperimentState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ExperimentState' enum
fromExperimentState :: ExperimentState -> Text
fromExperimentState = \case
  ExperimentState'Running   -> "running"
  ExperimentState'Succeeded -> "succeeded"
  ExperimentState'Failed    -> "failed"
  ExperimentState'Aborted   -> "aborted"

-- | parse 'ExperimentState' enum
toExperimentState :: Text -> P.Either String ExperimentState
toExperimentState = \case
  "running" -> P.Right ExperimentState'Running
  "succeeded" -> P.Right ExperimentState'Succeeded
  "failed" -> P.Right ExperimentState'Failed
  "aborted" -> P.Right ExperimentState'Aborted
  s -> P.Left $ "toExperimentState: enum parse failure: " P.++ P.show s


-- ** InvitationStatusEnumDTO

-- | Enum of 'Text'
data InvitationStatusEnumDTO = InvitationStatusEnumDTO'Pending
    | InvitationStatusEnumDTO'Accepted
    | InvitationStatusEnumDTO'Rejected
    | InvitationStatusEnumDTO'Revoked
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON InvitationStatusEnumDTO where toJSON = A.toJSON . fromInvitationStatusEnumDTO
instance A.FromJSON InvitationStatusEnumDTO where parseJSON o = P.either P.fail (pure . P.id) . toInvitationStatusEnumDTO =<< A.parseJSON o
instance WH.ToHttpApiData InvitationStatusEnumDTO where toQueryParam = WH.toQueryParam . fromInvitationStatusEnumDTO
instance WH.FromHttpApiData InvitationStatusEnumDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toInvitationStatusEnumDTO
instance MimeRender MimeMultipartFormData InvitationStatusEnumDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'InvitationStatusEnumDTO' enum
fromInvitationStatusEnumDTO :: InvitationStatusEnumDTO -> Text
fromInvitationStatusEnumDTO = \case
  InvitationStatusEnumDTO'Pending  -> "pending"
  InvitationStatusEnumDTO'Accepted -> "accepted"
  InvitationStatusEnumDTO'Rejected -> "rejected"
  InvitationStatusEnumDTO'Revoked  -> "revoked"

-- | parse 'InvitationStatusEnumDTO' enum
toInvitationStatusEnumDTO :: Text -> P.Either String InvitationStatusEnumDTO
toInvitationStatusEnumDTO = \case
  "pending" -> P.Right InvitationStatusEnumDTO'Pending
  "accepted" -> P.Right InvitationStatusEnumDTO'Accepted
  "rejected" -> P.Right InvitationStatusEnumDTO'Rejected
  "revoked" -> P.Right InvitationStatusEnumDTO'Revoked
  s -> P.Left $ "toInvitationStatusEnumDTO: enum parse failure: " P.++ P.show s


-- ** InvitationTypeEnumDTO

-- | Enum of 'Text'
data InvitationTypeEnumDTO = InvitationTypeEnumDTO'User
    | InvitationTypeEnumDTO'EmailRecipient
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON InvitationTypeEnumDTO where toJSON = A.toJSON . fromInvitationTypeEnumDTO
instance A.FromJSON InvitationTypeEnumDTO where parseJSON o = P.either P.fail (pure . P.id) . toInvitationTypeEnumDTO =<< A.parseJSON o
instance WH.ToHttpApiData InvitationTypeEnumDTO where toQueryParam = WH.toQueryParam . fromInvitationTypeEnumDTO
instance WH.FromHttpApiData InvitationTypeEnumDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toInvitationTypeEnumDTO
instance MimeRender MimeMultipartFormData InvitationTypeEnumDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'InvitationTypeEnumDTO' enum
fromInvitationTypeEnumDTO :: InvitationTypeEnumDTO -> Text
fromInvitationTypeEnumDTO = \case
  InvitationTypeEnumDTO'User           -> "user"
  InvitationTypeEnumDTO'EmailRecipient -> "emailRecipient"

-- | parse 'InvitationTypeEnumDTO' enum
toInvitationTypeEnumDTO :: Text -> P.Either String InvitationTypeEnumDTO
toInvitationTypeEnumDTO = \case
  "user" -> P.Right InvitationTypeEnumDTO'User
  "emailRecipient" -> P.Right InvitationTypeEnumDTO'EmailRecipient
  s -> P.Left $ "toInvitationTypeEnumDTO: enum parse failure: " P.++ P.show s


-- ** LinkTypeDTO

-- | Enum of 'Text'
data LinkTypeDTO = LinkTypeDTO'Github
    | LinkTypeDTO'Twitter
    | LinkTypeDTO'Kaggle
    | LinkTypeDTO'Linkedin
    | LinkTypeDTO'Other
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LinkTypeDTO where toJSON = A.toJSON . fromLinkTypeDTO
instance A.FromJSON LinkTypeDTO where parseJSON o = P.either P.fail (pure . P.id) . toLinkTypeDTO =<< A.parseJSON o
instance WH.ToHttpApiData LinkTypeDTO where toQueryParam = WH.toQueryParam . fromLinkTypeDTO
instance WH.FromHttpApiData LinkTypeDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLinkTypeDTO
instance MimeRender MimeMultipartFormData LinkTypeDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LinkTypeDTO' enum
fromLinkTypeDTO :: LinkTypeDTO -> Text
fromLinkTypeDTO = \case
  LinkTypeDTO'Github   -> "github"
  LinkTypeDTO'Twitter  -> "twitter"
  LinkTypeDTO'Kaggle   -> "kaggle"
  LinkTypeDTO'Linkedin -> "linkedin"
  LinkTypeDTO'Other    -> "other"

-- | parse 'LinkTypeDTO' enum
toLinkTypeDTO :: Text -> P.Either String LinkTypeDTO
toLinkTypeDTO = \case
  "github"   -> P.Right LinkTypeDTO'Github
  "twitter"  -> P.Right LinkTypeDTO'Twitter
  "kaggle"   -> P.Right LinkTypeDTO'Kaggle
  "linkedin" -> P.Right LinkTypeDTO'Linkedin
  "other"    -> P.Right LinkTypeDTO'Other
  s          -> P.Left $ "toLinkTypeDTO: enum parse failure: " P.++ P.show s


-- ** LoginActionDTO

-- | Enum of 'Text'
data LoginActionDTO = LoginActionDTO'SET_USERNAME
    | LoginActionDTO'SURVEY
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LoginActionDTO where toJSON = A.toJSON . fromLoginActionDTO
instance A.FromJSON LoginActionDTO where parseJSON o = P.either P.fail (pure . P.id) . toLoginActionDTO =<< A.parseJSON o
instance WH.ToHttpApiData LoginActionDTO where toQueryParam = WH.toQueryParam . fromLoginActionDTO
instance WH.FromHttpApiData LoginActionDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLoginActionDTO
instance MimeRender MimeMultipartFormData LoginActionDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LoginActionDTO' enum
fromLoginActionDTO :: LoginActionDTO -> Text
fromLoginActionDTO = \case
  LoginActionDTO'SET_USERNAME -> "SET_USERNAME"
  LoginActionDTO'SURVEY       -> "SURVEY"

-- | parse 'LoginActionDTO' enum
toLoginActionDTO :: Text -> P.Either String LoginActionDTO
toLoginActionDTO = \case
  "SET_USERNAME" -> P.Right LoginActionDTO'SET_USERNAME
  "SURVEY" -> P.Right LoginActionDTO'SURVEY
  s -> P.Left $ "toLoginActionDTO: enum parse failure: " P.++ P.show s


-- ** NameEnum

-- | Enum of 'Text'
data NameEnum = NameEnum'Client
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON NameEnum where toJSON = A.toJSON . fromNameEnum
instance A.FromJSON NameEnum where parseJSON o = P.either P.fail (pure . P.id) . toNameEnum =<< A.parseJSON o
instance WH.ToHttpApiData NameEnum where toQueryParam = WH.toQueryParam . fromNameEnum
instance WH.FromHttpApiData NameEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toNameEnum
instance MimeRender MimeMultipartFormData NameEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'NameEnum' enum
fromNameEnum :: NameEnum -> Text
fromNameEnum = \case
  NameEnum'Client -> "Client"

-- | parse 'NameEnum' enum
toNameEnum :: Text -> P.Either String NameEnum
toNameEnum = \case
  "Client" -> P.Right NameEnum'Client
  s        -> P.Left $ "toNameEnum: enum parse failure: " P.++ P.show s


-- ** OrganizationRoleDTO

-- | Enum of 'Text'
data OrganizationRoleDTO = OrganizationRoleDTO'Member
    | OrganizationRoleDTO'Owner
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrganizationRoleDTO where toJSON = A.toJSON . fromOrganizationRoleDTO
instance A.FromJSON OrganizationRoleDTO where parseJSON o = P.either P.fail (pure . P.id) . toOrganizationRoleDTO =<< A.parseJSON o
instance WH.ToHttpApiData OrganizationRoleDTO where toQueryParam = WH.toQueryParam . fromOrganizationRoleDTO
instance WH.FromHttpApiData OrganizationRoleDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrganizationRoleDTO
instance MimeRender MimeMultipartFormData OrganizationRoleDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrganizationRoleDTO' enum
fromOrganizationRoleDTO :: OrganizationRoleDTO -> Text
fromOrganizationRoleDTO = \case
  OrganizationRoleDTO'Member -> "member"
  OrganizationRoleDTO'Owner  -> "owner"

-- | parse 'OrganizationRoleDTO' enum
toOrganizationRoleDTO :: Text -> P.Either String OrganizationRoleDTO
toOrganizationRoleDTO = \case
  "member" -> P.Right OrganizationRoleDTO'Member
  "owner" -> P.Right OrganizationRoleDTO'Owner
  s -> P.Left $ "toOrganizationRoleDTO: enum parse failure: " P.++ P.show s


-- ** OrganizationTypeDTO

-- | Enum of 'Text'
data OrganizationTypeDTO = OrganizationTypeDTO'Individual
    | OrganizationTypeDTO'Team
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrganizationTypeDTO where toJSON = A.toJSON . fromOrganizationTypeDTO
instance A.FromJSON OrganizationTypeDTO where parseJSON o = P.either P.fail (pure . P.id) . toOrganizationTypeDTO =<< A.parseJSON o
instance WH.ToHttpApiData OrganizationTypeDTO where toQueryParam = WH.toQueryParam . fromOrganizationTypeDTO
instance WH.FromHttpApiData OrganizationTypeDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrganizationTypeDTO
instance MimeRender MimeMultipartFormData OrganizationTypeDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrganizationTypeDTO' enum
fromOrganizationTypeDTO :: OrganizationTypeDTO -> Text
fromOrganizationTypeDTO = \case
  OrganizationTypeDTO'Individual -> "individual"
  OrganizationTypeDTO'Team       -> "team"

-- | parse 'OrganizationTypeDTO' enum
toOrganizationTypeDTO :: Text -> P.Either String OrganizationTypeDTO
toOrganizationTypeDTO = \case
  "individual" -> P.Right OrganizationTypeDTO'Individual
  "team" -> P.Right OrganizationTypeDTO'Team
  s -> P.Left $ "toOrganizationTypeDTO: enum parse failure: " P.++ P.show s


-- ** ParameterTypeEnum

-- | Enum of 'Text'
data ParameterTypeEnum = ParameterTypeEnum'Double
    | ParameterTypeEnum'String
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ParameterTypeEnum where toJSON = A.toJSON . fromParameterTypeEnum
instance A.FromJSON ParameterTypeEnum where parseJSON o = P.either P.fail (pure . P.id) . toParameterTypeEnum =<< A.parseJSON o
instance WH.ToHttpApiData ParameterTypeEnum where toQueryParam = WH.toQueryParam . fromParameterTypeEnum
instance WH.FromHttpApiData ParameterTypeEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toParameterTypeEnum
instance MimeRender MimeMultipartFormData ParameterTypeEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ParameterTypeEnum' enum
fromParameterTypeEnum :: ParameterTypeEnum -> Text
fromParameterTypeEnum = \case
  ParameterTypeEnum'Double -> "double"
  ParameterTypeEnum'String -> "string"

-- | parse 'ParameterTypeEnum' enum
toParameterTypeEnum :: Text -> P.Either String ParameterTypeEnum
toParameterTypeEnum = \case
  "double" -> P.Right ParameterTypeEnum'Double
  "string" -> P.Right ParameterTypeEnum'String
  s        -> P.Left $ "toParameterTypeEnum: enum parse failure: " P.++ P.show s


-- ** PricingPlanDTO

-- | Enum of 'Text'
data PricingPlanDTO = PricingPlanDTO'Free
    | PricingPlanDTO'Academia
    | PricingPlanDTO'Paid
    | PricingPlanDTO'Enterprise
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PricingPlanDTO where toJSON = A.toJSON . fromPricingPlanDTO
instance A.FromJSON PricingPlanDTO where parseJSON o = P.either P.fail (pure . P.id) . toPricingPlanDTO =<< A.parseJSON o
instance WH.ToHttpApiData PricingPlanDTO where toQueryParam = WH.toQueryParam . fromPricingPlanDTO
instance WH.FromHttpApiData PricingPlanDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPricingPlanDTO
instance MimeRender MimeMultipartFormData PricingPlanDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PricingPlanDTO' enum
fromPricingPlanDTO :: PricingPlanDTO -> Text
fromPricingPlanDTO = \case
  PricingPlanDTO'Free       -> "free"
  PricingPlanDTO'Academia   -> "academia"
  PricingPlanDTO'Paid       -> "paid"
  PricingPlanDTO'Enterprise -> "enterprise"

-- | parse 'PricingPlanDTO' enum
toPricingPlanDTO :: Text -> P.Either String PricingPlanDTO
toPricingPlanDTO = \case
  "free" -> P.Right PricingPlanDTO'Free
  "academia" -> P.Right PricingPlanDTO'Academia
  "paid" -> P.Right PricingPlanDTO'Paid
  "enterprise" -> P.Right PricingPlanDTO'Enterprise
  s -> P.Left $ "toPricingPlanDTO: enum parse failure: " P.++ P.show s


-- ** ProjectCodeAccessDTO

-- | Enum of 'Text'
data ProjectCodeAccessDTO = ProjectCodeAccessDTO'Default
    | ProjectCodeAccessDTO'Restricted
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ProjectCodeAccessDTO where toJSON = A.toJSON . fromProjectCodeAccessDTO
instance A.FromJSON ProjectCodeAccessDTO where parseJSON o = P.either P.fail (pure . P.id) . toProjectCodeAccessDTO =<< A.parseJSON o
instance WH.ToHttpApiData ProjectCodeAccessDTO where toQueryParam = WH.toQueryParam . fromProjectCodeAccessDTO
instance WH.FromHttpApiData ProjectCodeAccessDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toProjectCodeAccessDTO
instance MimeRender MimeMultipartFormData ProjectCodeAccessDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ProjectCodeAccessDTO' enum
fromProjectCodeAccessDTO :: ProjectCodeAccessDTO -> Text
fromProjectCodeAccessDTO = \case
  ProjectCodeAccessDTO'Default    -> "default"
  ProjectCodeAccessDTO'Restricted -> "restricted"

-- | parse 'ProjectCodeAccessDTO' enum
toProjectCodeAccessDTO :: Text -> P.Either String ProjectCodeAccessDTO
toProjectCodeAccessDTO = \case
  "default" -> P.Right ProjectCodeAccessDTO'Default
  "restricted" -> P.Right ProjectCodeAccessDTO'Restricted
  s -> P.Left $ "toProjectCodeAccessDTO: enum parse failure: " P.++ P.show s


-- ** ProjectRoleDTO

-- | Enum of 'Text'
data ProjectRoleDTO = ProjectRoleDTO'Viewer
    | ProjectRoleDTO'Member
    | ProjectRoleDTO'Manager
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ProjectRoleDTO where toJSON = A.toJSON . fromProjectRoleDTO
instance A.FromJSON ProjectRoleDTO where parseJSON o = P.either P.fail (pure . P.id) . toProjectRoleDTO =<< A.parseJSON o
instance WH.ToHttpApiData ProjectRoleDTO where toQueryParam = WH.toQueryParam . fromProjectRoleDTO
instance WH.FromHttpApiData ProjectRoleDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toProjectRoleDTO
instance MimeRender MimeMultipartFormData ProjectRoleDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ProjectRoleDTO' enum
fromProjectRoleDTO :: ProjectRoleDTO -> Text
fromProjectRoleDTO = \case
  ProjectRoleDTO'Viewer  -> "viewer"
  ProjectRoleDTO'Member  -> "member"
  ProjectRoleDTO'Manager -> "manager"

-- | parse 'ProjectRoleDTO' enum
toProjectRoleDTO :: Text -> P.Either String ProjectRoleDTO
toProjectRoleDTO = \case
  "viewer"  -> P.Right ProjectRoleDTO'Viewer
  "member"  -> P.Right ProjectRoleDTO'Member
  "manager" -> P.Right ProjectRoleDTO'Manager
  s         -> P.Left $ "toProjectRoleDTO: enum parse failure: " P.++ P.show s


-- ** ProjectVisibilityDTO

-- | Enum of 'Text'
data ProjectVisibilityDTO = ProjectVisibilityDTO'Priv
    | ProjectVisibilityDTO'Pub
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ProjectVisibilityDTO where toJSON = A.toJSON . fromProjectVisibilityDTO
instance A.FromJSON ProjectVisibilityDTO where parseJSON o = P.either P.fail (pure . P.id) . toProjectVisibilityDTO =<< A.parseJSON o
instance WH.ToHttpApiData ProjectVisibilityDTO where toQueryParam = WH.toQueryParam . fromProjectVisibilityDTO
instance WH.FromHttpApiData ProjectVisibilityDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toProjectVisibilityDTO
instance MimeRender MimeMultipartFormData ProjectVisibilityDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ProjectVisibilityDTO' enum
fromProjectVisibilityDTO :: ProjectVisibilityDTO -> Text
fromProjectVisibilityDTO = \case
  ProjectVisibilityDTO'Priv -> "priv"
  ProjectVisibilityDTO'Pub  -> "pub"

-- | parse 'ProjectVisibilityDTO' enum
toProjectVisibilityDTO :: Text -> P.Either String ProjectVisibilityDTO
toProjectVisibilityDTO = \case
  "priv" -> P.Right ProjectVisibilityDTO'Priv
  "pub" -> P.Right ProjectVisibilityDTO'Pub
  s -> P.Left $ "toProjectVisibilityDTO: enum parse failure: " P.++ P.show s


-- ** SeriesType

-- | Enum of 'Text'
data SeriesType = SeriesType'Line
    | SeriesType'Dot
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SeriesType where toJSON = A.toJSON . fromSeriesType
instance A.FromJSON SeriesType where parseJSON o = P.either P.fail (pure . P.id) . toSeriesType =<< A.parseJSON o
instance WH.ToHttpApiData SeriesType where toQueryParam = WH.toQueryParam . fromSeriesType
instance WH.FromHttpApiData SeriesType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSeriesType
instance MimeRender MimeMultipartFormData SeriesType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SeriesType' enum
fromSeriesType :: SeriesType -> Text
fromSeriesType = \case
  SeriesType'Line -> "line"
  SeriesType'Dot  -> "dot"

-- | parse 'SeriesType' enum
toSeriesType :: Text -> P.Either String SeriesType
toSeriesType = \case
  "line" -> P.Right SeriesType'Line
  "dot"  -> P.Right SeriesType'Dot
  s      -> P.Left $ "toSeriesType: enum parse failure: " P.++ P.show s


-- ** SystemMetricResourceType

-- | Enum of 'Text'
data SystemMetricResourceType = SystemMetricResourceType'CPU
    | SystemMetricResourceType'RAM
    | SystemMetricResourceType'GPU
    | SystemMetricResourceType'GPU_RAM
    | SystemMetricResourceType'OTHER
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SystemMetricResourceType where toJSON = A.toJSON . fromSystemMetricResourceType
instance A.FromJSON SystemMetricResourceType where parseJSON o = P.either P.fail (pure . P.id) . toSystemMetricResourceType =<< A.parseJSON o
instance WH.ToHttpApiData SystemMetricResourceType where toQueryParam = WH.toQueryParam . fromSystemMetricResourceType
instance WH.FromHttpApiData SystemMetricResourceType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSystemMetricResourceType
instance MimeRender MimeMultipartFormData SystemMetricResourceType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SystemMetricResourceType' enum
fromSystemMetricResourceType :: SystemMetricResourceType -> Text
fromSystemMetricResourceType = \case
  SystemMetricResourceType'CPU     -> "CPU"
  SystemMetricResourceType'RAM     -> "RAM"
  SystemMetricResourceType'GPU     -> "GPU"
  SystemMetricResourceType'GPU_RAM -> "GPU_RAM"
  SystemMetricResourceType'OTHER   -> "OTHER"

-- | parse 'SystemMetricResourceType' enum
toSystemMetricResourceType :: Text -> P.Either String SystemMetricResourceType
toSystemMetricResourceType = \case
  "CPU" -> P.Right SystemMetricResourceType'CPU
  "RAM" -> P.Right SystemMetricResourceType'RAM
  "GPU" -> P.Right SystemMetricResourceType'GPU
  "GPU_RAM" -> P.Right SystemMetricResourceType'GPU_RAM
  "OTHER" -> P.Right SystemMetricResourceType'OTHER
  s -> P.Left $ "toSystemMetricResourceType: enum parse failure: " P.++ P.show s


-- ** UsernameValidationStatusEnumDTO

-- | Enum of 'Text'
data UsernameValidationStatusEnumDTO = UsernameValidationStatusEnumDTO'Available
    | UsernameValidationStatusEnumDTO'Invalid
    | UsernameValidationStatusEnumDTO'Unavailable
    deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UsernameValidationStatusEnumDTO where toJSON = A.toJSON . fromUsernameValidationStatusEnumDTO
instance A.FromJSON UsernameValidationStatusEnumDTO where parseJSON o = P.either P.fail (pure . P.id) . toUsernameValidationStatusEnumDTO =<< A.parseJSON o
instance WH.ToHttpApiData UsernameValidationStatusEnumDTO where toQueryParam = WH.toQueryParam . fromUsernameValidationStatusEnumDTO
instance WH.FromHttpApiData UsernameValidationStatusEnumDTO where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUsernameValidationStatusEnumDTO
instance MimeRender MimeMultipartFormData UsernameValidationStatusEnumDTO where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UsernameValidationStatusEnumDTO' enum
fromUsernameValidationStatusEnumDTO :: UsernameValidationStatusEnumDTO -> Text
fromUsernameValidationStatusEnumDTO = \case
  UsernameValidationStatusEnumDTO'Available   -> "available"
  UsernameValidationStatusEnumDTO'Invalid     -> "invalid"
  UsernameValidationStatusEnumDTO'Unavailable -> "unavailable"

-- | parse 'UsernameValidationStatusEnumDTO' enum
toUsernameValidationStatusEnumDTO :: Text -> P.Either String UsernameValidationStatusEnumDTO
toUsernameValidationStatusEnumDTO = \case
  "available" -> P.Right UsernameValidationStatusEnumDTO'Available
  "invalid" -> P.Right UsernameValidationStatusEnumDTO'Invalid
  "unavailable" -> P.Right UsernameValidationStatusEnumDTO'Unavailable
  s -> P.Left $ "toUsernameValidationStatusEnumDTO: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthOAuthOauth2
data AuthOAuthOauth2 = AuthOAuthOauth2 Text
    deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthOAuthOauth2 where
  applyAuthMethod _ a@(AuthOAuthOauth2 secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", "Bearer " <> secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


